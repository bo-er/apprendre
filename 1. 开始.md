**1.下载**

Windows: https://golang.org/dl/go1.15.6.windows-amd64.msi

Mac: https://golang.org/dl/go1.15.6.darwin-amd64.pkg

Linux:https://golang.org/dl/go1.15.6.linux-amd64.tar.gz

 **2. 开始第一个Hello World程序**

1. ​    Open a command prompt and cd to your home directory.     

   ​      On Linux or Mac:    

   ```
   cd
   ```

   ​      On Windows:    

   ```
   cd %HOMEPATH%
   ```

2. ​    Create a hello directory for your first Go source code.     

   ​      For example, use the following commands:    

   ```
   mkdir hello
   cd hello
   ```

3. ​    In your text editor, create a file hello.go in which to write your code.  

4. ​    Paste the following code into your hello.go file and save the file.     

   ```
   package main
   
   import "fmt"
   
   func main() {
       fmt.Println("Hello, World!")
   }
   ```

   fmt是一个包含了文本格式化函数、打印函数的包。

5. ​    Run your code to see the greeting.     

   ```
   $ go run hello.go
   Hello, World!
   ```

**3.在外部package调用函数**

要让自己的代码可以被外部包调用：

```go
$ go mod init hello
go: creating new go.mod: module hello
```

需要注意的一点是，任何给外部包，以及项目根目录里的main函数使用的函数都应该在一个包里。

官方文档:

Go programs are organized into packages. **A package is a collection of source files in the same directory that are compiled together.** Functions, types, variables, and constants defined in one source file are visible to all other source files within the same package.

A repository contains one or more modules. A module is a collection of related Go packages that are released together. A Go repository typically contains only one module, located at the root of the repository. A file named `go.mod` there declares the module path: the import path prefix for all packages within the module. The module contains the packages in the directory containing its `go.mod` file as well as subdirectories of that directory, up to the next subdirectory containing another `go.mod` file (if any).

Note that you don't need to publish your code to a remote repository before you can build it. A module can be defined locally without belonging to a repository. However, it's a good habit to organize your code as if you will publish it someday.

Each module's path not only serves as an import path prefix for its packages, but also indicates where the `go` command should look to download it. For example, in order to download the module `golang.org/x/tools`, the `go` command would consult the repository indicated by `https://golang.org/x/tools` (described more [here](https://golang.org/cmd/go/#hdr-Relative_import_paths)).

**An import path is a string used to import a package. A package's import path is its module path joined with its subdirectory within the module.** For example, the module `github.com/google/go-cmp` contains a package in the directory `cmp/`. That package's import path is `github.com/google/go-cmp/cmp`. Packages in the standard library do not have a module path prefix.

一个package引入另外一个package的函数有三种情况:

1. 两个package都在一个项目（都在同一个go module下)
2. 两个package不在同一个module但是在同一个地址（比如说两个位置不同的文件夹)
3. 一个package import github上面的资源

对于第一种情况

创建项目后go mod init test，那么引入根目录下一个文件夹external中定义的函数Sayhi( )的方法是:

比如需要在main函数中引入

```go
package main

import (
	"test/external"
)

func main(){
	external.Sayhi()
}
```

需要注意的是提供给包外使用的函数首字母必须大写。

第二种情况:

第一种情况caller跟callee都在同一个Module，而第二种情况caller跟callee不在同一个Module，因此需要引入module.

如果是第三种情况直接引入github包就可以了。而第二种情况由于模块在本地另外一个文件夹，需要做的额外操作是在go.mod文件中修改来源。

做法是在go.mod文件中使用**replace**:

需要注意的是require的是go.mod所在目录，不能写require hello/external ,会提示找不到go.mod

```
require hello

replace hello => "../go hello"
```

然后使用的时候同样是

mport "hello/external"

然后 external.Sayhi( ) ,使用包名作为caller

第三种情况

需要注意的一件事情是：由于go在下载module的时候会去proxy.golang.org校核下载的包，不管你是否刚刚提交了github代码，这个网站上会存储你的历史提交并且过一段时间才会刷新，因此如果你push了新的版本然后使用go mod tidy你会发现下载下来的是历史版本并且哪怕你清理掉本地缓存也不会有任何效果。。

The go command defaults to downloading modules from the public Go module mirror at proxy.golang.org. It also defaults to validating downloaded modules, regardless of source, against the public Go checksum database at sum.golang.org. These defaults work well for publicly available source code.

解决这个问题的办法是:

通过设置GOPRIVATE来跳过私有库，比如github跟gitlab

```
go env -w GOPRIVATE=*.github.com/bo-er,*.gitlab.org/14038
```



**4. 基本名词**

如果在电脑执行go env命令:

```
GO111MODULE="auto"
GOARCH="amd64"
GOBIN="/Users/steve/go/bin"
GOCACHE="/Users/steve/Library/Caches/go-build"
GOENV="/Users/steve/Library/Application Support/go/env"
GOEXE=""
GOFLAGS=""
GOHOSTARCH="amd64"
GOHOSTOS="darwin"
GOINSECURE=""
GOMODCACHE="/Users/steve/go/pkg/mod"
GONOPROXY=""
GONOSUMDB=""
GOOS="darwin"
GOPATH="/Users/steve/go"
GOPRIVATE=""
GOPROXY="https://proxy.golang.org,direct"
GOROOT="/usr/local/go"
GOSUMDB="sum.golang.org"
GOTMPDIR=""
GOTOOLDIR="/usr/local/go/pkg/tool/darwin_amd64"
GCCGO="gccgo"
AR="ar"
CC="clang"
CXX="clang++"
CGO_ENABLED="1"
GOMOD=""
CGO_CFLAGS="-g -O2"
CGO_CPPFLAGS=""
CGO_CXXFLAGS="-g -O2"
CGO_FFLAGS="-g -O2"
CGO_LDFLAGS="-g -O2"
PKG_CONFIG="pkg-config"
GOGCCFLAGS="-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/5y/vj4hwy553y53q9hnqh21bnjr0000gn/T/go-build062271267=/tmp/go-build -gno-record-gcc-switches -fno-common"
```

**GOROOT **  :  go的安装路径

**GOPATH**

将gopath引入当前工作目录:

```
export PATH=$PATH:$(go env GOPATH)/bin
```

包含三个文件夹

**bin** : 编译后生成的可执行文件

**src** : 存放程序代码（工作目录)  在go的安装目录GOROOT里找到src你会看到go自带的package代码

**pkg** : 存放编译后的.a文件

**go get** : 从远程下载包并且执行go install

go get的目录下必须有一个main函数,否则不被认为是一个可执行目录

**go install** : go install 会生成可执行文件直接放到bin目录下，当然这是有前提的
 你编译的是可执行文件，如果是一个普通的包，会被编译生成到pkg目录下该文件是.a结尾

实际上go在2009年推出的时候，go还没有包管理器，大家只能用go get来下载各种包然后这些包将被放到$GOPATH/src下，没有version的概念。而Module在go的1.11版本正式开始使用因此上面的配置中有一个GO111MODULE，它现在的值被设置为auto,GO111MODULE有三个值： **auto    on   off**

- `GO111MODULE=on` will force using Go modules even if the project is in your GOPATH. Requires `go.mod` to work.
- `GO111MODULE=off` forces Go to behave the GOPATH way, even outside of GOPATH.
- `GO111MODULE=auto` is the default mode. In this mode, Go will behave
  - similarly to `GO111MODULE=on` when you are outside of `GOPATH`,
  - similarly to `GO111MODULE=off` when you are inside the `GOPATH` even if a `go.mod` is present.

**Vendor**

Go get的代码都会放到go path下，go get有一个问题是永远下载最新的版本，无法指定版本。

注释

外部可见函数注释函数名称首字母大写，外部不可见函数注释名称首字母大小写都可以