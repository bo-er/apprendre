## 持续性会话

为了接收来自[MQTT 代理的](https://www.hivemq.com/hivemq/)消息，客户端连接到代理并创建对其感兴趣[的主题的订阅](https://www.hivemq.com/blog/mqtt-essentials-part-5-mqtt-topics-best-practices/)。如果客户端和代理之间的连接在非持久会话期间中断，则这些主题将丢失，并且客户端需要在重新连接时再次订阅。每次连接中断时都要重新订阅，这对于资源有限的受限制客户端来说是一个负担。为了避免此问题，客户端可以在连接到代理时请求持久会话。持久会话将与客户端有关的所有信息保存在代理上。客户端在建立与代理的连接时提供的*clientId*标识会话（[更多详细信息](https://www.hivemq.com/blog/mqtt-essentials-part-3-client-broker-connection-establishment/)）。

### 持久会话中存储了什么？

在持久会话中，代理存储以下信息（即使客户端处于脱机状态）。当客户端重新连接时，该信息立即可用。

- 会话的存在（即使没有订阅）。
- 客户端的所有订阅。
- 客户尚未确认[的服务质量（QoS）](https://www.hivemq.com/blog/mqtt-essentials-part-6-mqtt-quality-of-service-levels/) 1 或 2 中的所有消息流。
- 客户端脱机时错过的所有新 QoS 1 或 2 消息。
- 从客户端收到的尚未完全确认的所有 QoS 2 消息。

### 您如何开始或结束持久会话？

当客户端连接到代理时，它可以请求持久会话。客户端使用*cleanSession*标志告诉代理它需要哪种会话：

- 当`clean session`标志设置为 true 时，客户端不需要持久会话。如果客户端由于任何原因断开连接，则从先前的持久性会话排队的所有信息和消息都将丢失。
- 当`clean session`标志设置为 false 时，代理将为客户端创建一个持久会话。所有信息和消息都将保留，直到客户端下次请求`clean session`为止。如果将`clean session`标志设置为 false，并且代理已经有可用于客户端的会话，则代理将使用现有会话并将先前排队的消息传递给客户端。

有关客户机与代理之间的连接建立的更多信息，请参见[MQTT Essentials 的第 3 部分](https://www.hivemq.com/blog/mqtt-essentials-part-3-client-broker-connection-establishment/)。

### 客户端如何知道会话是否已经存储？

从 MQTT 3.1.1 开始，来自代理的*CONNACK*消息包含*会话存在标志*。此标志告诉客户端代理上是否仍然可以使用以前建立的会话。有关建立连接的更多信息，请参见 [MQTT Essentials 的第 3 部分](https://www.hivemq.com/blog/mqtt-essentials-part-3-client-broker-connection-establishment/)。

### 客户端上的持久会话

与代理类似，每个 MQTT 客户端也必须存储一个持久会话。当客户端请求服务器保留会话数据时，客户端负责存储以下信息：

- 代理尚未确认的 QoS 1 或 2 流中的所有消息。
- 从代理收到的所有尚未完全确认的 QoS 2 消息。

## 最佳实践

以下是一些准则，可以帮助您决定何时使用持久会话或clean session：

### 持续性会话

- 客户端必须从某个主题获得所有消息，即使它处于脱机状态。您希望代理将客户端的消息排队，并在客户端重新联机后立即传递它们。
- 客户资源有限。您希望代理存储客户端的订阅信息并快速恢复中断的通信。
- 重新连接后，客户端需要恢复所有 QoS 1 和 2 发布消息。

### Clean Session

- 客户端只需要向主题发布消息，客户端就不需要订阅主题。您不希望代理存储会话信息或重试 QoS 1 和 2 消息的传输。
- 客户端不需要获取脱机错过的消息。

### 代理将消息存储多长时间？

人们经常问`broker`将会话存储多长时间。一个简单的答案是：代理存储会话，直到客户端重新联机并接收消息。但是，_如果客户长时间不在线会怎样？_ 通常，操作系统的内存限制是消息存储的主要限制。对于这种情况没有标准答案。正确的解决方案取决于您的用例。
