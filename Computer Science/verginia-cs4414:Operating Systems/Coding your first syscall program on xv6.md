# Happy Learning Day

## What is a system call

### 操作系统的位置

app 1 app 2 app 3

--- Process Virtual Machine ---

**Operating System**

--- System Virtual Machine ---

hardware

### 操作系统提供给 Process Virtual Machine 的接口

- threads = 进程虚拟机想象中的 CPU
- address space = 进程虚拟机想象中的内存
- processes = threads + address space
- files
- sockets

### 硬件提供给操作系统的接口

- interrupts
- memory addresses
- special register
- memory-mapped devices
- I/O buses

## 机制 1

CPU 的处理器有着`kernel(privileged)`跟`user`两种模式，有一些指令只能在`kernel`模式下进行。

### rules

- 用户代码永远在`user`模式下运行
- 只有 OS 的代码才能在`kernel`模式下运行

上面的 rules 只有一种例外:

**将`user`模式转为`kernel`模式**

## 机制 2

程序 A 有地址空间，由 OS 映射到真实的内存中，但是部分内存区域只能在`kernel`模式下才能映射。

应用程序的进程只能调用 OS 的接口。如果进程需要硬件资源那么就需要让 OS 调用硬件接口，这个时候就需要进行`system call`.

## XV6

- XV6 是轻量的操作系统
- XV6 可以安装为独立的操作系统，但是不推荐这么做
- XV6 可以在模拟器环境运行,推荐这么做
- QEMU 是用来运行 XV6 的模拟器

### 如何添加 system call

下面的内容来自[xv6intro](https://www.cs.virginia.edu/~cr4bd/4414/S2019/xv6intro.html)

Basic steps for adding system calls:

1. Create a `sys_writecount` function based on an existing simple system call function like `sys_uptime`. (For this assignment, you do not need to (but are allowed to) use a spinlock and `acquire` or `release` like `uptime` does since we do not care how your code works with multiple processors.)
2. Add a system call number for your new system call to `syscall.h`.
3. Add your `sys_writecount` to the table in `syscall.c`.
4. Edit `sys_write`. You can use a command like `grep sys_write *.c` to find out where it is.
5. Edit `usys.S` and `user.h` to create a system call wrapper function that invokes your system call from a normal user program.

实际操作后需要修改的地方包括了:

1. syscall.h
2. syscall.c
3. sysproc.c
4. usys.S
5. user.h

### 已有的 syscall 是如何实现的

虽然网上的很多资料说 syscall 定义在`usys.S`里，但是至少在我的环境(riscv-gnu-toolchain:v9.2.0,qemu:4.1.0,OS:x86_64-apple-darwin20.2.0,xv6-riscv-fall19@dbb036fc071e6323a7a294c392d158bc36abc91f)
打开`usys.S`后看到的第一行内容是:

```
#generated by usys.pl - do not edit`
```

很明显应该看`usys.pl`而不是`usys.S`里的内容。

下面是`usys.pl`里的内容:

```c
#!/usr/bin/perl -w

# Generate usys.S, the stubs for syscalls.

print "# generated by usys.pl - do not edit\n";

print "#include \"kernel/syscall.h\"\n";

sub entry {
    my $name = shift;
    print ".global $name\n";
    print "${name}:\n";
    print " li a7, SYS_${name}\n";
    print " ecall\n";
    print " ret\n";
}

entry("fork");
entry("exit");
entry("wait");
entry("pipe");
entry("read");
entry("write");
entry("close");
entry("kill");
entry("exec");
entry("open");
entry("mknod");
entry("unlink");
entry("fstat");
entry("link");
entry("mkdir");
entry("chdir");
entry("dup");
entry("getpid");
entry("sbrk");
entry("sleep");
entry("uptime");
entry("ntas");

```

作为爱可生的专业程序员，你不可能忽略掉 `#!/usr/bin/perl -w`,很明显这是一个用 perl 写的脚本，因此文件名也是`pl`后缀,
上面的内容中的`sub`其实是 perl 的[子程序](https://www.runoob.com/perl/perl-subroutines.html)。Perl 的子程序也就是用户定义的函数，也就是说下面的`entry("***")`都是在执行 entry 函数。这个函数的作用就是往`usys.S`中写入 syscall 的定义。以`echo`作为例子:

```
.global getpid
getpid:
 li a7, SYS_getpid
 ecall
 ret
```

这里的`usys.S`是用户态系统调用的接口,可以看到这里将`getpid`定义为了对链接器可见的全局变量,然后是定义`getpid`。
`li a7, SYS_getpid`将系统调用`SYS_getpid`压入 a7 寄存器
。接着通过`ecall`指令调用 syscall，`ecall`会修改特权等级，并且进入到内核控制的某个函数入口。

然后查看 user.h,这里定义了`usys.S`接口中的system call包装函数- getpid以及标准的库函数。

````c
int getpid(void);

``

接着到`kernel/syscall.c`文件中寻找跟`getpid`相关的内容:

由于sys_getpid并没有定义在`syscall.c`里所以下面的一行是必须的。

```c
extern uint64 sys_getpid(void);
````

```c
static uint64 (*syscalls[])(void) = {
    ...
    [SYS_getpid]  sys_getpid,
    ...
}
```

`SYS_getpid`实际上是定义在 syscall.h 中的宏,这意味着syscall.c中出现的`SYS_getpid`都将被替换为11:

```c
#define SYS_getpid 11

```

再看看 syscall.c 中定义的 syscall 函数:

```c
void
syscall(void)
{
  int num;
  struct proc *p = myproc();
  //将a7中存的11存到num变量
  num = p->tf->a7;
  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
    //执行syscall函数，将结果存到a0寄存器中
    p->tf->a0 = syscalls[num]();
  } else {
    printf("%d %s: unknown sys call %d\n",
            p->pid, p->name, num);
    // 不满足执行条件将-1存到a0寄存器中
    p->tf->a0 = -1;
  }
}

```

那么到了这里还剩 getpid 的实现代码了,在`sysproc.c`中可以找到:

```c
uint64
sys_getpid(void)
{
  return myproc()->pid;
}

```

### 添加自定义的 syscall

这里准备写一个简单的返回自己年纪的syscall...



1. 修改 xv6-riscv-fall19/user 目录下的`usys.pl`脚本，在最下面添加一行:

```c
entry("getage")
```

2. 修改 xv6-riscv-fall19/user 目录下的`user.h`文件，增加用户态接口的函数定义:

```c
int getage(void);

```

3. 修改xv6-riscv-fall19/kernel 目录下的`syscall.h`,添加新的宏定义:

```c
#define SYS_hello = 23
```

4. 在xv6-riscv-fall19/kernel 目录下的`syscall.c`指针数组中添加一项指针:

```c
static uint64 (*syscalls[])(void) = {
    ...
    [SYS_getage]  sys_getage,
    ...
}
```

由于我们没有在`syscall.c`中实现syscall函数因此需要在`syscall.c`中添加syscall的prototype:

```c
extern uint64 sys_getage(void);
````

5. 接着到xv6-riscv-fall19/kernel 目录下的`sysproc.c`文件去实现syscall:

```c
int
sys_getage(void)
{
return 25;
}
```

6. 编写调用syscall的用户代码

在xv6-riscv-fall19/user 目录里增加一个文件getage.c:

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

uint64
main(void)
{
printf("Hello, my name is steve and I am %d years old.\n", getage());
    exit(0);
}
```
7. 最后一步是修改Makefile, Makefile中`UPROGS` 的部分是需要构建的程序，这里需要加上一行告诉make构建`getage`程序。

```
$U/_getage\

```

接着执行`make`来构建xv6,最后执行`make qemu`来启动QEMU模拟器。

直接输入`getage`就能看到结果。