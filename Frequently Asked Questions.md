## 起源 [¶](https://golang.org/doc/faq#Origins)

### 该项目的目的是什么？

在Go诞生之初（仅十年前），编程世界与今天有所不同。生产软件通常用C ++或Java编写，GitHub不存在，大多数计算机还没有多处理器，除了Visual Studio和Eclipse之外，几乎没有可用的IDE或其他高级工具，更不用说在互联网上免费了。

同时，我们对于使用与我们一起开发服务器软件所使用的语言所需的过度复杂性感到沮丧。自从首先开发诸如C，C ++和Java之类的语言以来，计算机已经变得非常快，但是编程本身并没有进步太多。同样，很明显，多处理器正在变得普遍，但是大多数语言对有效，安全地编程它们几乎没有帮助。

我们决定退后一步，考虑随着技术的发展，未来几年哪些主要问题将主导软件工程，以及一种新的语言如何帮助解决这些问题。例如，多核CPU的兴起表明，一种语言应为某种并发性或并行性提供一流的支持。为了使资源管理在大型并发程序中易于处理，需要垃圾回收或至少某种安全的自动内存管理。

这些考虑导致 [了一系列讨论](https://commandcenter.blogspot.com/2017/09/go-ten-years-and-climbing.html)，Go引起[了一系列讨论](https://commandcenter.blogspot.com/2017/09/go-ten-years-and-climbing.html)，首先是一系列思想和愿望，然后是一种语言。一个总体目标是，Go可以通过启用工具，自动执行诸如代码格式化之类的平凡任务以及消除在大型代码库上工作的障碍，来为工作中的程序员提供更多帮助。

[在Google的Go语言：软件工程服务中的语言设计中](https://talks.golang.org/2012/splash.article) ，可以找到关于[Go语言](https://talks.golang.org/2012/splash.article)的目标以及如何实现或至少达到这些目标的更广泛的描述 。

### 该项目的历史如何？

Robert Griesemer，Rob Pike和Ken Thompson于2007年9月21日开始在白板上草拟一种新语言的目标。几天之内，这些目标就已经定下来，成为了做某事的计划以及对它的想法。继续进行兼职工作，同时进行无关的工作。到2008年1月，Ken开始研究一种编译器，以探索思想。它生成C代码作为其输出。到年中，该语言已成为一个全职项目，并且已经定下来足以尝试生产编译器。2008年5月，伊恩·泰勒（Ian Taylor）使用规范草案独立地开始了Go的GCC前端。拉斯·考克斯（Russ Cox）于2008年末加入，并帮助将语言和库从原型转变为现实。

Go于2009年11月10日成为公共开源项目。社区中无数的人贡献了想法，讨论和代码。

现在，全球有数以百万计的Go程序员（专家），而且每天都有更多的程序员。Go的成功远远超出了我们的期望。

### 地鼠吉祥物的起源是什么？

吉祥物和徽标由[RenéeFrench](https://reneefrench.blogspot.com/)设计 ，后者还设计 了Plan 9兔子[Glenda](https://9p.io/plan9/glenda.html)。一个[博客帖子](https://blog.golang.org/gopher) 有关的gopher解释它是如何从一个她用于衍生[WFMU](https://wfmu.org/) 几年前的T恤设计。徽标和吉祥物受 [知识共享署名3.0](https://creativecommons.org/licenses/by/3.0/) 许可的保护。

地鼠有一个 [模型表，](https://golang.org/doc/gopher/modelsheet.jpg) 说明了他的特征以及如何正确表示它们。模型表首先在 Renée于2016年Gophercon的一次 [演讲](https://www.youtube.com/watch?v=4rw_B4yY69k)中展示。他是*Go地鼠*，而不仅仅是任何老地鼠。

### 语言是Go还是Golang？

该语言称为Go。该“golang”绰号的出现是因为该网站是 [golang.org](https://golang.org/)，不go.org，这是不提供给我们。不过，许多人都使用golang名称，它很容易用作标签。例如，该语言的Twitter标记是“ #golang”。不管怎样，该语言的名称只是普通的Go。

旁注：尽管 [官方徽标](https://blog.golang.org/go-brand) 有两个大写字母，但语言名称写为Go，而不是GO。

### 您为什么要创建一种新语言？

Go诞生于对我们在Google所做的工作的现有语言和环境的沮丧。编程变得太困难了，部分语言应归咎于语言的选择。人们必须选择高效的编译，高效的执行或易于编程。这三种语言均无法以相同的主流语言提供。选择使用动态类型化的语言（例如Python和JavaScript）而不是C ++或在较小程度上使用Java的程序员可能会在安全性和效率上放轻松。

我们并不孤单。经过多年的编程语言一片平静之后，Go成为了几种新语言（Rust，Elixir，Swift等）中的第一种，这使编程语言开发再次成为活跃的，几乎是主流的领域。

Go通过尝试将解释型动态类型语言的编程易用性,与静态类型编译语言的效率和安全性相结合，解决了这些问题。它还旨在成为现代化的，并支持网络和多核计算。最后，使用Go的目的是要*快*：在一台计算机上构建大型可执行文件最多需要几秒钟。为了实现这些目标，需要解决许多语言问题：一个富有表现力但轻巧的字体系统；并发和垃圾回收；严格的依赖规范；等等。库或工具无法很好地解决这些问题；需要一种新的语言。

[Google上](https://talks.golang.org/2012/splash.article) 的文章[Go](https://talks.golang.org/2012/splash.article) 讨论了Go语言设计背后的背景和动机，并提供了有关此FAQ中提供的许多答案的更多详细信息。

### Go的祖先是什么？

Go主要属于C族（基本语法），其中Pascal / Modula / Oberon族（声明，程序包）投入了大量精力，此外，Tony Hoare的CSP启发了一些语言灵感，例如Newsqueak和Limbo（并发）。但是，这是一门全新的语言。在各个方面，都通过考虑程序员的工作方式以及如何使程序设计（至少是我们所做的编程类型）更有效，更有趣的方式来设计该语言。

### 设计中的指导原则是什么？

在设计Go时，至少在Google来说，Java和C ++是编写服务器的最常用语言。我们认为这些语言需要太多的簿记和重复。一些程序员通过以更高效，更流畅的语言（例如Python）为代价，以牺牲效率和类型安全为代价。我们认为用一种语言就能具有效率，安全性和流动性。

Go尝试减少两种词义的打字量。在整个设计过程中，我们一直努力减少混乱和复杂性。没有前向声明，也没有头文件；一切都只被声明一次。初始化具有表现力，自动且易于使用。语法简洁明了。`foo.Foo* myFoo = new(foo.Foo)`通过使用`:=` 声明并初始化结构的简单类型派生，减少了口吃（）。也许最根本，没有类型层次：类型只是*是*，他们没有宣布他们的关系。这些简化使Go可以表达而又易于理解，而不会牺牲复杂性。

另一个重要原则是保持概念正交。可以针对任何类型实现方法；结构代表数据，而接口代表抽象；等等。正交性使人们更容易理解事物组合时会发生什么。

## 用法

### Google在内部使用Go吗？

是的。Go在Google内部的生产中被广泛使用。一个简单的例子是[golang.org](https://golang.org/)后面的服务器 。它只是[`godoc`](https://golang.org/cmd/godoc) 在[Google App Engine](https://developers.google.com/appengine/)上的生产配置中运行的文档服务器 。

更为重要的实例是Google的下载服务器，`dl.google.com`该服务器可提供Chrome二进制文件和其他大型可安装程序（例如`apt-get` 软件包）。

Go并不是Google唯一使用的语言，它远不是它，但它是许多领域的关键语言，包括 [站点可靠性工程（SRE）](https://talks.golang.org/2013/go-sreops.slide) 和大规模数据处理。

### 还有哪些公司使用Go？

Go的使用在全球范围内都在增长，特别是但绝不是在云计算领域中。用Go编写的几个主要的云基础架构项目是Docker和Kubernetes，但还有更多。

但是，不仅仅是云。Go Wiki包含定期更新的[页面](https://github.com/golang/go/wiki/GoUsers)，该 [页面](https://github.com/golang/go/wiki/GoUsers)列出了许多使用Go的公司。

Wiki也有一个页面，其中包含指向 有关使用该语言的公司和项目的[成功案例的](https://github.com/golang/go/wiki/SuccessStories)链接 。

### Go程序是否与C / C ++程序链接？

可以在相同的地址空间中一起使用C和Go，但这并不是很自然的选择，可能需要特殊的接口软件。同样，将C与Go代码链接会放弃Go提供的内存安全性和堆栈管理属性。有时，绝对有必要使用C库来解决问题，但是这样做总是会引入纯Go代码所没有的风险元素，因此请务必谨慎。

如果确实需要将C与Go一起使用，如何进行取决于Go编译器的实现。Go团队支持三种Go编译器实现。它们是`gc`，默认编译器 `gccgo`使用GCC后端，而较不成熟的`gollvm`使用LLVM基础结构。

`Gc`使用与C不同的调用约定和链接器，因此不能直接从C程序调用，反之亦然。该[`cgo`](https://golang.org/cmd/cgo/)程序提供了“外部函数接口”的机制，以允许从Go代码安全地调用C库。SWIG将此功能扩展到C ++库。

您也可以将`cgo`和SWIG与`Gccgo`和一起使用`gollvm`。由于它们使用传统的API，因此也可以非常小心地将来自这些编译器的代码直接与GCC / LLVM编译的C或C ++程序链接。但是，安全地执行此操作需要了解所有相关语言的调用约定，以及从Go调用C或C ++时要注意的堆栈限制。

### Go支持哪些IDE？

Go项目不包括自定义IDE，但已设计语言和库来简化源代码分析。结果，大多数知名的编辑器和IDE都直接或通过插件支持Go良好。

具有良好的Go支持的知名IDE和编辑器列表包括Emacs，Vim，VSCode，Atom，Eclipse，Sublime，IntelliJ（通过名为Goland的自定义变体）等。您最喜欢的环境是在Go中进行编程的高效环境。

### Go是否支持Google的协议缓冲区？

一个单独的开源项目提供了必要的编译器插件和库。可从 [github.com/golang/protobuf/获得](https://github.com/golang/protobuf)。

### 我可以将“首页”翻译成另一种语言吗？

绝对地。我们鼓励开发人员以自己的语言制作Go语言网站。但是，如果您选择将Google徽标或品牌添加到您的网站（它不会出现在[golang.org上](https://golang.org/)），则需要遵守[www.google.com/permissions/guidelines.html上](https://www.google.com/permissions/guidelines.html)的准则

## 设计

### Go有运行时吗？

Go确实有一个广泛的库，称为*runtime*，它是每个Go程序的一部分。运行时库实现垃圾收集，并发，堆栈管理和Go语言的其他关键功能。尽管Go语言对语言更重要，但其运行时类似于`libc`C库。

但是，重要的是要了解，Go的运行时不包括Java运行时提供的虚拟机。Go程序会提前编译为本地机器代码（对于某些变体实现，则为JavaScript或WebAssembly）。因此，尽管该术语通常用于描述程序在其中运行的虚拟环境，但是在Go语言中，“运行时”一词只是赋予提供关键语言服务的库的名称。

### Unicode标识符是怎么回事？

在设计Go时，我们要确保它不是以ASCII为中心的，这意味着要从7位ASCII的范围扩展标识符的空间。Go的规则-识别符必须是Unicode定义的字母或数字-易于理解和实现，但有限制。例如，组合字符在设计上被排除在外，并且排除了某些语言，例如梵文。

这条规则还有另一个不幸的后果。由于导出的标识符必须以大写字母开头，因此根据定义，不能导出由某些语言的字符创建的标识符。目前唯一的解决方案是使用`X日本語`，这显然不能令人满意。

自从该语言的最早版本发布以来，人们一直在思考如何最好地扩展标识符空间以适应使用其他本机语言的程序员。确切地，做什么仍然是讨论的活跃话题，并且该语言的未来版本在标识符定义方面可能会更加宽松。例如，它可能会采用Unicode组织 关于标识符的[建议中的](http://unicode.org/reports/tr31/)一些想法。无论发生什么事情，都必须在兼容（或扩展）字母大小写确定标识符可见性的方式下兼容完成，这仍然是Go最受欢迎的功能之一。

目前，我们有一个简单的规则，可以在以后扩展而又不破坏程序，该规则避免了肯定会因允许歧义标识符的规则而引起的错误。

### 为什么Go没有功能X？

每种语言都包含新颖的功能，并且会忽略某人喜欢的功能。Go的设计着眼于编程的实用性，编译速度，概念的正交性以及对支持诸如并发和垃圾收集等功能的需求。您最喜欢的功能可能会丢失，因为它不合适，因为它会影响编译速度或设计的清晰度，或者因为它将使基本系统模型变得太困难。

如果困扰您Go缺少功能X，请原谅我们并调查Go确实具有的功能。您可能会发现它们以有趣的方式补偿了X的缺失。

### 为什么Go没有泛型类型？

一个[实现泛型类型的形式语言的建议](https://golang.org/issue/43651)已被接受列入语言。如果一切顺利，它将在Go 1.18版本中可用。

Go旨在作为一种编写服务器程序的语言，随着时间的推移该服务器程序将易于维护。（有关更多背景信息，请参阅[本文](https://talks.golang.org/2012/splash.article)。）设计集中在可伸缩性，可读性和并发性等方面。当时，多态编程对于该语言的目标似乎并不重要，因此为简单起见而被省略。

该语言现在更加成熟，可以考虑某种形式的通用编程。但是，仍然存在一些警告。

泛型很方便，但是它们以类型系统和运行时的复杂性为代价。尽管我们一直在考虑，但是我们还没有找到一种能使价值与复杂性成比例的设计。同时，Go的内置映射和切片，以及使用空接口构造容器的能力（带有显式拆箱），意味着在许多情况下，即使编写得不太顺利，也有可能编写能够实现泛型的代码。

该主题保持打开状态。要查看以前为Go设计良好的泛型解决方案的失败尝试，请参阅 [此建议](https://golang.org/issue/15292)。

### 为什么Go没有例外？

我们相信，如`try-catch-finally`习惯用法那样，将异常耦合到控制结构会导致代码混乱。它还倾向于鼓励程序员将太多的常见错误（例如，无法打开文件）标记为例外。

Go采用了不同的方法。对于简单的错误处理，Go的多值返回使报告错误变得容易，而不会使返回值过载。 [规范错误类型与Go的其他功能一起](https://golang.org/doc/articles/error_handling.html)使错误处理令人愉悦，但与其他语言完全不同。

Go还具有一些内置功能，可以发出信号并从真正异常的状况中恢复。恢复机制仅在发生错误后被破坏的功能状态的一部分中执行，该机制足以处理灾难，但不需要额外的控制结构，如果使用得当，可以生成干净的错误处理代码。

有关详细信息[，](https://golang.org/doc/articles/defer_panic_recover.html)请参见[延缓，紧急情况和恢复](https://golang.org/doc/articles/defer_panic_recover.html)文章。另外，“[错误就是价值”](https://blog.golang.org/errors-are-values)博客文章通过证明由于错误只是值而明确描述了一种在Go中清晰处理错误的方法，因此Go的全部功能都可以部署在错误处理中。

### 为什么Go没有断言？

Go不提供断言。它们无疑是很方便的，但是我们的经验是程序员将它们用作拐杖，以避免思考正确的错误处理和报告。正确的错误处理意味着服务器可以继续运行，而不是在发生非致命错误后崩溃。正确的错误报告意味着错误是直接的并指向重点，从而使程序员不必解释大型的崩溃跟踪。当程序员看到的错误不熟悉代码时，精确的错误尤为重要。

我们知道这是一个争论点。Go语言和库中有许多与现代实践不同的东西，仅仅是因为我们认为有时值得尝试不同的方法。

### 为什么要在CSP的思想上建立并发性？

随着时间的流逝，并发和多线程编程已因困难而闻名。我们认为，这部分是由于复杂的设计（例如[pthread）](https://en.wikipedia.org/wiki/POSIX_Threads) ，部分是由于 过分强调了底层细节（例如互斥锁，条件变量和内存屏障）。更高级别的接口可以实现更简单的代码，即使幕后仍然有互斥对象等。

Hoare的通信顺序过程（CSP）是为并发提供高级语言支持的最成功模型之一。Occam和Erlang是源自CSP的两种众所周知的语言。Go的并发原语来自家族树的不同部分，其主要贡献是将通道作为一流对象的强大概念。几种早期语言的经验表明，CSP模型非常适合过程语言框架。

### 为什么使用goroutines而不是线程？

Goroutine是使并发易于使用的一部分。这个想法已经存在了一段时间，它是将独立执行的功能（协程）复用到一组线程上。当协程阻塞时，例如通过调用阻塞系统调用，运行时会自动将同一操作系统线程上的其他协程移动到另一个可运行的线程中，这样它们就不会被阻塞。程序员对此一无所知，这就是重点。我们称之为goroutines的结果可能非常便宜：它们在堆栈内存（只有几千字节）之外的开销很小。

为了缩小堆栈，Go的运行时使用可调整大小的有界堆栈。给一个新铸造的goroutine几千字节，这几乎总是足够的。否则，运行时会增加（或缩小）用于自动存储堆栈的内存，从而使许多goroutine可以驻留在适度的内存中。每个函数调用的CPU开销平均约为3条廉价指令。在同一地址空间中创建数十万个goroutine是很实际的。如果goroutine只是线程，那么系统资源将以更少的数量耗尽。

### 为什么未将映射操作定义为原子操作？

经过长时间的讨论，人们决定使用地图的典型用法不需要从多个goroutine安全访问，并且在需要的情况下，地图可能是某些已经同步的较大数据结构或计算的一部分。因此，要求所有映射操作都获取互斥量将减慢大多数程序的速度，并增加少数程序的安全性。但是，这并不是一个容易的决定，因为这意味着不受控制的地图访问可能会使程序崩溃。

该语言不排除原子图更新。在需要时（例如在托管不受信任的程序时），实现可以互锁地图访问。

仅在进行更新时，地图访问才是不安全的。只要所有goroutine仅读取（在地图中查找元素，包括使用`for` `range`循环对其进行遍历）， 并且不通过分配元素或进行删除来更改地图，则对于它们来说，在不同步的情况下并发访问地图是安全的。

为了更正地图的使用，该语言的某些实现包含特殊检查，当通过并发执行不安全地修改地图时，该检查会在运行时自动报告。

### 您会接受我的语言更改吗？

人们通常会建议对语言进行改进（ [邮件列表](https://groups.google.com/group/golang-nuts) 包含此类讨论的丰富历史），但是这些更改很少被接受。

尽管Go是一个开源项目，但是语言和库受到[兼容性保证的](https://golang.org/doc/go1compat.html)保护，该[兼容性保证](https://golang.org/doc/go1compat.html)至少在源代码级别上可以防止破坏现有程序的更改（可能有时需要重新编译程序以保持最新）。如果您的建议违反了Go 1规范，则无论其价值如何，我们都无法接受。Go的未来主要发行版可能与Go 1不兼容，但是关于该主题的讨论才刚刚开始，并且可以肯定的是：在此过程中几乎不会引入这种不兼容性。而且，兼容性承诺鼓励我们为出现这种情况的旧程序提供自动前进的路径。

即使您的建议与Go 1规范兼容，也可能不符合Go的设计目标。*[前往Google](https://talks.golang.org/2012/splash.article)*的文章*[：软件工程服务中的语言设计](https://talks.golang.org/2012/splash.article)* 说明了Go的起源以及其设计背后的动机。

## 种类

### Go是一种面向对象的语言吗？

是的，没有。尽管Go具有类型和方法，并允许使用面向对象的编程风格，但没有类型层次结构。Go中的“接口”概念提供了一种不同的方法，我们认为该方法易于使用并且在某些方面更通用。还有一些方法可以将类型嵌入其他类型，以提供与子类类似（但不完全相同）的东西。而且，Go中的方法比C ++或Java中的方法更通用：可以为任何类型的数据定义它们，甚至可以将内置类型（例如普通的“未装箱”整数）定义为它们。它们不限于结构（类）。

而且，缺乏类型层次结构使得Go中的“对象”比C ++或Java等语言更轻量。

### 如何动态分配方法？

动态分配方法的唯一方法是通过接口。结构或任何其他具体类型上的方法总是静态解析的。

### 为什么没有类型继承？

至少以最著名的语言进行的面向对象编程涉及对类型之间的关系的过多讨论，而这些关系通常可以自动导出。Go采用了不同的方法。

在Go中，类型无需自动声明两种类型相关联，而可以自动满足指定其方法子集的任何接口。除了减少簿记之外，这种方法还具有真正的优势。类型可以一次满足许多接口，而无需传统多重继承的复杂性。接口可以是非常轻量级的-具有一个或什至零个方法的接口可以表达一个有用的概念。如果有新想法出现或要进行测试，则可以在事实之后添加接口，而无需注释原始类型。因为类型和接口之间没有明确的关系，所以没有类型层次结构可以管理或讨论。

可以使用这些想法来构造类似于类型安全的Unix管道的东西。例如，查看如何`fmt.Fprintf` 对所有输出（不仅是文件）启用格式化打印，或者如何将 `bufio`包与文件I / O完全分开，或者`image`包如何生成压缩的图像文件。所有这些想法都源于`io.Writer`代表一个单一方法（`Write`）的单一界面（）。而这只是表面。Go的界面对程序的结构产生了深远的影响。

这需要一些时间来适应，但是这种隐式类型依赖类型是Go最具生产力的事情之一。

### 为什么是`len`函数而不是方法？

我们对这个问题进行了辩论，但是决定将实现`len`和朋友当作函数在实践中很好，并且没有使关于基本类型的接口（从Go类型意义上的问题）复杂化。

### 为什么Go不支持方法和运算符的重载？

如果方法分派也不需要进行类型匹配，则可以简化方法分派。其他语言的经验告诉我们，使用具有相同名称但签名不同的各种方法有时会很有用，但在实践中也可能会造成混淆和脆弱。在Go的类型系统中，仅按名称进行匹配并要求类型一致是一个简化的主要决定。

关于操作员重载，似乎比绝对要求更方便。同样，没有它，事情会更简单。

### 为什么Go没有“实现”声明？

Go类型通过实现该接口的方法来满足该接口，仅此而已。此属性允许定义和使用接口，而无需修改现有代码。它实现了一种 [结构化类型化](https://en.wikipedia.org/wiki/Structural_type_system)，可以促进关注点分离并提高代码重用性，并使得在代码开发时出现的模式上更容易构建。接口的语义是Go敏捷，轻便的感觉的主要原因之一。

有关更多详细信息，请参见[类型继承问题](https://golang.org/doc/faq#inheritance)。

### 如何保证我的类型满足接口要求？

您可以要求编译器通过尝试使用零值或指向的赋值来尝试 检查类型是否`T`实现了接口： `I``T``T`

```
输入T struct {}
var _ I = T {} //验证T是否实现I。
var _ I =（* T）（nil）//验证* T是否实现I。
```

如果`T`（或`*T`相应地）未实现 `I`，则错误将在编译时捕获。

如果希望接口的用户显式声明他们实现了该接口，则可以在接口的方法集中添加一个具有描述性名称的方法。例如：

```
键入Fooer接口{
    Foo（）
    ImplementsFooer（）
}
```

然后，类型必须将`ImplementsFooer`方法实现为 `Fooer`，清楚地记录事实并在[go doc](https://golang.org/cmd/go/#hdr-Show_documentation_for_package_or_symbol)的输出中声明该事实 。

```
输入Bar struct {}
func（b Bar）ImplementsFooer（）{}
func（b Bar）Foo（）{}
```

大多数代码不使用此类约束，因为它们限制了接口概念的实用性。但是有时候，它们对于解决相似接口之间的歧义是必要的。

### 为什么类型T不满足Equal接口？

考虑这个简单的接口来表示一个可以与另一个值进行比较的对象：

```
类型等于接口{
    等于（等于）布尔
}
```

和这种类型`T`：

```
T int型
func（t T）Equal（u T）bool {return t == u} //不满足Equaler
```

与某些多态类型系统中的类似情况不同， `T`未实现`Equaler`。的参数类型`T.Equal`是`T`，不是字面上所需要的类型`Equaler`。

在Go中，类型系统不提升`Equal`;的参数 。这是程序员的责任，如type所示`T2`，它实现了 `Equaler`：

```
T2 int类型
func（t T2）Equal（u Equaler）bool {return t == u。（T2）} //满足Equaler
```

但是，即使这与其他类型系统也不一样，因为在Go中，*任何* 满足条件的类型`Equaler`都可以作为参数传递给`T2.Equal`，并且在运行时我们必须检查参数是否为type `T2`。一些语言安排在编译时做出保证。

一个相关的例子是相反的：

```
键入Opener界面{
   Open（）阅读器
}

func（t T3）Open（）* os.File
```

在Go`T3`中`Opener`，虽然可能会用另一种语言表示，但并不满足。

在这种情况下，Go的类型系统确实对程序员没有多大作用，但是缺少子类型化使得关于接口满意度的规则非常容易陈述：函数的名称和签名是否与接口的名称和签名完全相同？Go的规则也易于有效实施。我们认为这些好处弥补了自动类型提升的不足。如果有一天可以采用某种形式的多态类型输入，我们希望将有一种表达这些示例思想的方法，并且可以对它们进行静态检查。

### 我可以将[] T转换为[]接口{}吗？

不直接。语言规范不允许这样做，因为这两种类型在内存中的表示形式不同。有必要将元素分别复制到目标切片。本示例将的一个切片转换`int`为的一个切片 `interface{}`：

```
t：= [] int {1、2、3、4}
s：= make（[] interface {}，len（t））
对于i，v：=范围t {
    s [i] = v
}
```

### 如果T1和T2具有相同的基础类型，可以将[] T1转换为[] T2吗？

此代码示例的最后一行不会编译。

```
T1 int类型
T2 int类型
var t1 T1
var x = T2（t1）//确定
var st1 [] T1
var sx =（[] T2）（st1）//不好
```

在Go中，类型与方法紧密相关，因为每个命名类型都有一个（可能为空）方法集。一般规则是，您可以更改要转换的类型的名称（从而可能更改其方法集），但不能更改复合类型的元素的名称（和方法集）。Go要求您明确说明类型转换。

### 为什么我的nil错误值不等于nil？

在幕后，接口被实现为两个元素，即type`T` 和value `V`。 `V`是一个具体的值，例如`int`， `struct`或指针，永远都不是接口本身，并且具有type `T`。例如，如果我们存储`int`在接口值3，所得到的界面值具有，示意性地，（ ，）。`T=int` `V=3`该值`V`也称为接口的 *动态*值，因为给定的接口变量在程序执行期间可能拥有不同的值`V` （和相应的类型`T`）。

`nil`仅当`V`和都未设置`T` （`T=nil`，`V`未设置）时， 接口值才有效。特别是，`nil`接口将始终保留`nil`类型。如果我们将`nil`类型的指针存储`*int`在接口值内，则内部类型将`*int`与指针的值无关：（`T=*int`，`V=nil`）。因此，`nil` *即使`V`内部的指针值为，* 此类接口值也将是非*均匀的*`nil`。

当将`nil`值存储在接口值（例如`error`return）中 时，会出现这种情况，造成混乱。

```
func returnError（）错误{
	var p * MyError = nil
	如果bad（）{
		p =错误
	}
	return p //将始终返回非nil错误。
}
```

如果一切顺利，该函数将返回一个`nil` `p`，因此返回值为`error`接口值（`T=*MyError`，`V=nil`）。这意味着，如果调用者将返回的错误与进行比较`nil`，即使没有发生任何不良情况，它也始终看起来像是存在错误。要向`nil` `error`调用者返回一个专有名词，该函数必须返回一个显式的`nil`：

```
func returnError（）错误{
	如果bad（）{
		返回ErrBad
	}
	返回零
}
```

对于总是返回错误的函数，最好总是使用`error`其签名中的类型（如我们上面所做的那样），而不要使用诸如的具体类型`*MyError`，以帮助确保正确创建错误。举例来说，即使不是， [`os.Open`](https://golang.org/pkg/os/#Open) 返回的始终是具体类型 。 `error``nil`[`*os.PathError`](https://golang.org/pkg/os/#PathError)

每当使用接口时，都会出现与此处描述的情况类似的情况。请记住，如果接口中已存储任何具体值，则接口将不会`nil`。有关更多信息，请参阅 [《反射定律》](https://golang.org/doc/articles/laws_of_reflection.html)。

### 为什么没有像C中那样未加标签的联合？

未标记的联合会违反Go的内存安全保证。

### 为什么Go没有变体类型？

变体类型，也称为代数类型，提供了一种方法来指定值可能采用一组其他类型中的一种，但只能采用那些类型。系统编程中的一个常见示例将指出错误是网络错误，安全错误或应用程序错误，并允许调用者通过检查错误的类型来区分问题的根源。另一个示例是语法树，其中每个节点可以是不同的类型：声明，语句，赋值等等。

我们曾考虑将变体类型添加到Go中，但是经过讨论后，他们决定将它们排除在外，因为它们与接口的混淆方式重叠。如果变量类型的元素本身是接口，将会发生什么？

同样，该语言已经涵盖了某些变体类型所针对的内容。使用接口值来保存错误并使用类型开关来区分大小写，很容易表达错误示例。语法树示例也是可行的，尽管不那么优雅。

### 为什么Go没有协变结果类型？

协变结果类型将意味着类似

```
类型可复制接口{
	Copy（）接口{}
}
```

将被该方法满足

```
func（v值）Copy（）值
```

因为`Value`实现了空接口。在Go中，方法类型必须完全匹配，因此`Value`不实现`Copyable`。Go将类型的功能（方法）与类型的实现分开。如果两个方法返回不同的类型，则它们不会做相同的事情。想要协变结果类型的程序员通常试图通过接口表达类型层次。在Go中，接口与实现之间的清晰区分是很自然的。

## 价值观

### 为什么Go不提供隐式数值转换？

C语言中的数字类型之间自动转换的便利性被它引起的混乱所笼罩。表达式何时无符号？价值多少？它会溢出吗？结果是否可移植，独立于执行它的机器？这也使编译器复杂化。“通常的算术转换”不容易实现，并且在整个体系结构中不一致。出于可移植性的原因，我们决定以代码中的一些显式转换为代价，使事情变得清晰明了。但是，在Go中定义常量（任意精度值没有符号和大小注释）可以大大改善问题。

一个相关的细节是，与C语言 不同，即使是64位类型`int`，`int64`它们也是不同的类型`int`。的`int` 类型是通用的; 如果您关心整数可以容纳多少位，那么Go鼓励您保持明确。

### 常量在Go中如何工作？

尽管Go严格要求在不同数值类型的变量之间进行转换，但是语言中的常数要灵活得多。文字常量如`23`，`3.14159` 和[`math.Pi`](https://golang.org/pkg/math/#pkg-constants) 占据一种的理想数空间，以任意精度和没有溢出或下溢。例如，`math.Pi`在源代码中将的值指定为63个位置，并且涉及该值的常量表达式保持的精度超出了a的精度`float64`。只有将常量或常量表达式分配给变量时（程序中的存储位置），它才会成为具有常规浮点属性和精度的“计算机”数字。

另外，由于它们只是数字，而不是类型化的值，因此Go中的常量比变量可以更自由地使用，从而减轻了严格转换规则周围的一些尴尬。一个人可以写这样的表达式

```
sqrt2：= math.Sqrt（2）
```

无需编译器投诉，因为理想的数字`2` 可以安全且准确地转换`float64`为调用`math.Sqrt`。

名为[Constants](https://blog.golang.org/constants)的博客文章 更详细地探讨了此主题。

### 为什么内置地图？

同样的原因是：字符串是如此强大而重要的数据结构，以至于在语法支持下提供了一种出色的实现，使编程更加愉快。我们认为Go的地图实施能力足够强大，可以用于绝大多数用途。如果一个特定的应用程序可以从定制实现中受益，则可以编写一个应用程序，但是在语法上不会那么方便。这似乎是一个合理的权衡。

### 为什么地图不允许切片作为键？

映射查找需要等式运算符，而这些运算符不会实现。他们没有实现平等，因为在这些类型上没有很好地定义平等。有多种考虑因素，包括浅层比较与深层比较，指针与值比较，如何处理递归类型等等。我们可能会重新审视此问题-并且对slice实施平等将不会使任何现有程序无效-但在没有明确了解slice平等意味着什么的情况下，暂时将其排除在外比较容易。

在Go 1中，与以前的版本不同，为结构和数组定义了相等性，因此可以将此类用作映射键。但是，切片仍然没有平等的定义。

### 为什么数组是值时映射，切片和通道引用？

关于这个话题有很多历史。早期，映射和通道在语法上是指针，因此不可能声明或使用非指针实例。此外，我们在数组应如何工作方面也遇到了困难。最终，我们决定严格区分指针和值，使该语言更难使用。更改这些类型以用作对关联的共享数据结构的引用解决了这些问题。这项更改使该语言增加了一些令人遗憾的复杂性，但对可用性产生了很大影响：Go引入时成为一种更具生产力和舒适性的语言。

## 编写代码

### 图书馆如何记录？

有一个`godoc`用Go编写的程序，可以从源代码中提取软件包文档，并将其用作包含声明，文件等链接的网页。实例正在[golang.org/pkg/](https://golang.org/pkg/)上运行 。实际上，`godoc`在[golang.org/上](https://golang.org/)实现了完整站点 。

甲`godoc`实例可以被配置成提供在它显示的节目的符号的丰富的交互式静态分析; 详细信息在[这里](https://golang.org/lib/godoc/analysis/help.html)列出。

为了从命令行访问文档， [go](https://golang.org/pkg/cmd/go/)工具具有一个 [doc](https://golang.org/pkg/cmd/go/#hdr-Show_documentation_for_package_or_symbol) 子命令，该子命令可提供文本界面提供相同信息。

### 有Go程式设计风格指南吗？

没有明确的样式指南，尽管肯定存在可以识别的“ Go样式”。

Go建立了约定，以指导有关命名，布局和文件组织的决策。文档[有效围棋](https://golang.org/doc/effective_go.html) 包含有关这些主题的一些建议。更直接地，该程序`gofmt`是一台漂亮的打印机，其目的是强制执行布局规则。它取代了允许解释的通常的“做与不做”纲要。存储库中的所有Go代码以及开源世界中的绝大多数代码都已通过运行`gofmt`。

标题为[Go Code Review Comments](https://golang.org/s/comments)的文档 是有关Go习语的详细信息的很短的文章的集合，程序员通常会忽略这些文章。对于为Go项目进行代码审查的人员，它是一个方便的参考。

### 如何向Go库提交补丁？

库源位于`src`存储库的目录中。如果您要进行重大更改，请在上车之前在邮件列表中进行讨论。

有关如何继续的更多信息， 请参见文档“ [贡献给Go项目](https://golang.org/doc/contribute.html)”。

### 为什么克隆存储库时“获取”会使用HTTPS？

公司通常只允许标准TCP端口80（HTTP）和443（HTTPS）上的传出流量，从而阻止其他端口（包括TCP端口9418（git）和TCP端口22（SSH））上的传出流量。使用HTTPS而不是HTTP时，`git`默认情况下会强制执行证书验证，从而可以防止中间人攻击，窃听和篡改攻击。`go get`因此，该命令将HTTPS用于安全性。

`Git`可以配置为通过HTTPS进行身份验证，或使用SSH代替HTTPS。要通过HTTPS进行身份验证，您可以在`$HOME/.netrc`git所查询的文件中添加一行：

```
机器github.com登录用户名密码APIKEY
```

对于GitHub帐户，密码可以是 [个人访问令牌](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/)。

`Git`也可以配置为对与给定前缀匹配的URL使用SSH代替HTTPS。例如，要将SSH用于所有GitHub访问，请将这些行添加到您的`~/.gitconfig`：

```
[url“ ssh：//git@github.com/”]
	代替Of = https://github.com/
```

### 我应该如何使用“ go get”管理软件包版本？

自从项目开始以来，Go就没有明确的包版本概念，但是这种情况正在改变。版本控制是一个非常复杂的来源，尤其是在大型代码库中，并且花了一些时间来开发一种在足够多的情况下可以大规模适用于所有Go用户的方法。

Go 1.11发行版`go`以Go模块的形式向命令添加了新的实验性版本支持程序包版本控制。有关更多信息，请参阅[Go 1.11发行说明](https://golang.org/doc/go1.11#modules) 和[`go`命令文档](https://golang.org/cmd/go#hdr-Modules__module_versions__and_more)。

不管实际的软件包管理技术是什么，“ go get”和更大的Go工具链确实可以隔离具有不同导入路径的软件包。例如，即使标准库的`html/template`和库`text/template` 都是“包模板” ，也可以共存。这种观察为程序包作者和程序包用户提供了一些建议。

供公众使用的软件包在开发过程中应尝试保持向后兼容性。将[跳转到1兼容性原则，](https://golang.org/doc/go1compat.html)在这里有很好的参考：不要删除出口的名字，鼓励标签复合文字，等等。如果需要其他功能，请添加一个新名称而不是更改旧名称。如果需要完全中断，请使用新的导入路径创建一个新程序包。

如果您使用的是外部提供的软件包，并且担心它可能会以意想不到的方式更改，但尚未使用Go模块，则最简单的解决方案是将其复制到本地存储库中。这是Google内部采用的方法，该`go`命令通过一种称为“供应商”的技术来支持该 方法。这涉及将依赖项的副本存储在新的导入路径下，该路径将其标识为本地副本。有关详细信息，请参见[设计文档](https://golang.org/s/go15vendor)。

## 指针和分配

### 函数参数何时按值传递？

与C系列中的所有语言一样，Go中的所有内容都按值传递。也就是说，函数总是获得所传递事物的副本，就像有一个赋值语句将值分配给参数一样。例如，将`int`值传递给函数将构成的副本`int`，而将指针值传递将使指针的副本，而不是其指向的数据。（有关如何影响方法接收者的讨论，请参见[后面的部分](https://golang.org/doc/faq#methods_on_values_or_pointers)。）

映射和切片值的行为类似于指针：它们是包含指向基础映射或切片数据的指针的描述符。复制地图或切片值不会复制其指向的数据。复制接口值将复制存储在接口值中的事物。如果接口值包含一个结构，则复制接口值将复制该结构。如果接口值包含一个指针，则复制接口值将复制该指针，但不会复制它指向的数据。

注意，此讨论是关于操作的语义的。实际的实现可以应用优化以避免复制，只要优化不更改语义即可。

### 什么时候应该使用指向接口的指针？

几乎从不。接口值的指针仅在罕见，棘手的情况下出现，这些情况涉及伪装接口值的类型以进行延迟评估。

将指向接口值的指针传递给需要接口的函数是一个常见错误。编译器会抱怨此错误，但情况仍然令人困惑，因为有时需要一个 [指针来满足interface](https://golang.org/doc/faq#different_method_sets)。洞察力是，尽管指向具体类型的指针可以满足接口，但有一个例外*，指向接口的指针永远不能满足接口*。

考虑变量声明，

```
变种作家
```

打印函数`fmt.Fprintf`将满足条件的值作为第一个参数，`io.Writer`即实现规范`Write`方法的值。这样我们可以写

```
fmt.Fprintf（w，“ hello，world \ n”）
```

但是，如果我们传递的地址`w`，则该程序将无法编译。

```
fmt.Fprintf（＆w，“ hello，world \ n”）//编译时错误。
```

一个例外是，可以将任何值（甚至是指向接口的指针）分配给空接口类型（`interface{}`）的变量。即使这样，如果值是指向接口的指针，几乎可以肯定是一个错误。结果可能会令人困惑。

### 我应该在值或指针上定义方法吗？

```
func（s * MyStruct）pointerMethod（）{} //指针方法
func（s MyStruct）valueMethod（）{} //值的方法
```

对于不习惯使用指针的程序员，这两个示例之间的区别可能会造成混淆，但是情况实际上非常简单。在类型上定义方法时，接收器（`s`在以上示例中）的行为就像是该方法的参数一样。将接收器定义为值还是指针是一个同样的问题，就像函数参数应该是值还是指针一样。有几个注意事项。

首先，也是最重要的，该方法是否需要修改接收器？如果是这样，则接收者*必须*是指针。（切片和地图用作参考，因此它们的故事有些微妙，但是例如，要在方法中更改切片的长度，接收方仍必须是指针。）在上面的示例中，如果`pointerMethod`修改的字段`s`，调用方将看到这些更改，但是`valueMethod` 将调用方参数的副本（即传递值的定义）进行调用，因此，所做的更改对于调用方将是不可见的。

顺便说一句，在Java方法中，接收器始终是指针，尽管它们的指针性质有些掩饰（并且有人提议在语言中添加值接收器）。Go中的价值接收者是不寻常的。

其次是对效率的考虑。如果接收器很大，`struct`例如很大，那么使用指针接收器会便宜得多。

接下来是一致性。如果类型的某些方法必须具有指针接收器，则其余的方法也应具有指针接收器，因此无论如何使用该类型，方法集都是一致的。有关 详细信息，请参见[方法集](https://golang.org/doc/faq#different_method_sets)部分。

对于基本类型，切片和small之类的类型，`structs`值接收器非常便宜，因此，除非该方法的语义要求使用指针，否则值接收器将高效且清晰。

### new和make有什么区别？

简而言之：`new`分配内存，同时`make`初始化切片，映射和通道类型。

有关更多详细信息，请参见“[有效执行”](https://golang.org/doc/effective_go.html#allocation_new)的[相关部分](https://golang.org/doc/effective_go.html#allocation_new)。

### `int`64位计算机上 的大小是多少？

的大小`int`和`uint`为实现特定的，但给定的平台上彼此相同。为了实现可移植性，依赖于特定大小的值的代码应使用显式大小的类型，例如`int64`。在32位计算机上，编译器默认情况下使用32位整数，而在64位计算机上，整数具有64位。（从历史上看，这并不总是正确的。）

另一方面，浮点标量和复杂类型的大小始终是大小（没有类型`float`或`complex`基本类型），因为程序员在使用浮点数时应注意精度。用于（无类型的）浮点常量的默认类型为`float64`。因此`foo` `:=` `3.0`声明一个`foo` 类型为的变量`float64`。对于`float32`由（无类型的）常量初始化的变量，必须在变量声明中显式指定变量类型：

```
var foo float32 = 3.0
```

或者，必须为常数赋予类型，如所示 `foo := float32(3.0)`。

### 我如何知道在堆还是堆栈上分配了变量？

从正确性的角度来看，您不需要知道。只要有引用，Go中的每个变量都存在。实现选择的存储位置与语言的语义无关。

存储位置确实会影响编写高效的程序。如果可能，Go编译器将在该函数的堆栈框架中分配该函数本地的变量。但是，如果编译器无法证明函数返回后未引用该变量，则编译器必须在垃圾回收堆上分配该变量，以避免悬空指针错误。同样，如果局部变量很大，则将其存储在堆而不是堆栈上可能更有意义。

在当前的编译器中，如果使用了变量的地址，则该变量是在堆上分配的候选对象。但是，基本的*转义分析可以*识别某些情况，其中此类变量不会超出函数的返回范围，而是可以驻留在堆栈中。

### 为什么我的Go进程使用了那么多虚拟内存？

Go内存分配器保留了较大的虚拟内存区域作为分配空间。该虚拟内存在特定的Go进程本地；保留不会剥夺其他进程的内存。

要查找分配给Go进程的实际内存量，请使用Unix `top`命令并查阅`RES`（Linux）或 `RSIZE`（macOS）列。

## 并发

### 什么是原子操作？互斥锁呢？

可以在[Go Memory Model](https://golang.org/ref/mem)文档中找到有关[Go](https://golang.org/ref/mem)操作原子性的描述。

在[sync](https://golang.org/pkg/sync)和 [sync / atomic](https://golang.org/pkg/sync/atomic) 软件包中提供了低级同步和原子基元 。这些软件包适用于简单的任务，例如增加引用计数或保证小规模的互斥。

对于更高级别的操作（例如，并发服务器之间的协调），更高级别的技术可以带来更好的程序，而Go通过其goroutine和通道支持此方法。例如，您可以对程序进行结构设计，以便一次只对一个特定的数据负责一个goroutine。最初的[Go谚语](https://www.youtube.com/watch?v=PAAkCSZUG1c)概括了这种方法 ，

不要通过共享内存进行通信。而是通过通信共享内存。

有关此概念的详细讨论，请参见“[通过通信共享内存”](https://golang.org/doc/codewalk/sharemem/)代码步及其[ 相关文章](https://blog.golang.org/2010/07/share-memory-by-communicating.html)。

大型并发程序可能会从这两个工具箱中借用。

### 为什么我的程序在使用更多CPU时不能更快地运行？

程序是否在使用更多CPU的情况下运行得更快，取决于它所解决的问题。Go语言提供了并发原语，例如goroutine和channel，但是并发仅在基础问题本质上是并行时才启用并行。本质上是顺序的问题不能通过添加更多的CPU来加速，而那些可以分解为可以并行执行的碎片可以被加速，有时甚至可以大大加速。

有时添加更多的CPU可能会使程序变慢。实际上，与使用有用的计算相比，花费更多时间进行同步或通信的程序可能会在使用多个OS线程时出现性能下降的情况。这是因为在线程之间传递数据会涉及切换上下文，这会带来巨大的成本，并且随着CPU数量的增加，这种成本会增加。例如， 尽管Go规范中的[主筛示例](https://golang.org/ref/spec#An_example_package)启动了许多goroutine，但它们并没有明显的并行性。增加线程（CPU）的速度比加快速度的可能性更大。

有关此主题的更多详细信息，请参见标题为“ [并发不是并行性”的主题](https://blog.golang.org/2013/01/concurrency-is-not-parallelism.html)。

### 如何控制CPU的数量？

可同时执行goroutine的可用CPU数量由`GOMAXPROCS`Shell环境变量控制，该变量的默认值为可用CPU核心数量。因此，具有并行执行潜力的程序应默认在多CPU机器上实现。要更改要使用的并行CPU的数量，请设置环境变量或使用 运行时包的名称相似的 [功能](https://golang.org/pkg/runtime/#GOMAXPROCS)来配置运行时支持以使用不同数量的线程。将其设置为1消除了真正的并行性的可能性，从而迫使独立的goroutine轮流执行。

运行时可以分配的线程数超过的值，`GOMAXPROCS`以服务于多个未完成的I / O请求。 `GOMAXPROCS`仅影响一次实际可以执行多少个goroutine；系统调用中可能会任意阻止更多内容。

Go的goroutine调度程序虽然随着时间的推移已得到改进，但并没有达到所需的效果。将来，它可能会更好地优化对OS线程的使用。目前，如果存在性能问题，则按`GOMAXPROCS`应用程序设置可能会有所帮助。

### 为什么没有goroutine ID？

Goroutine没有名称；他们只是匿名工人。它们不会向程序员公开任何唯一的标识符，名称或数据结构。有些人对此感到惊讶，期望该`go` 语句返回一些可用于以后访问和控制goroutine的项目。

goroutines匿名的根本原因是，在编写并发代码时，可以使用完整的Go语言。相比之下，在命名线程和goroutine时开发的使用模式会限制使用它们的库的工作。

这是困难的例证。一旦命名了一个goroutine并在其周围构建了一个模型，它将变得很特别，并且人们倾向于将所有计算与该goroutine相关联，而忽略了使用多个可能共享的goroutine进行处理的可能性。如果`net/http`程序包将每个请求状态与goroutine关联，则客户端在处理请求时将无法使用更多goroutine。

此外，诸如要求用于“主线程”上进行所有处理的图形系统库之类的库的经验表明，当以并发语言部署时，该方法有多么尴尬和局限性。特殊线程或goroutine的存在迫使程序员扭曲程序，以避免因错误地对错误的线程进行操作而导致崩溃和其他问题。

对于特定的goroutine确实非常特殊的情况，该语言提供了诸如通道之类的功能，可以灵活地使用它们与之交互。

## 功能与方法

### 为什么T和* T具有不同的方法集？

如[Go规范](https://golang.org/ref/spec#Types)所述，类型的方法集`T`由具有接收器类型的所有方法组成`T`，而相应的指针类型`*T`的方法集由具有接收器`*T`或 的所有方法组成`T`。这意味着的方法集`*T` 包括的方法集`T`，但不包括相反的方法集。

之所以会出现这种区别，是因为如果接口值包含指针`*T`，则方法调用可以通过取消引用指针来获取值，但是如果接口值包含value `T`，则方法调用没有安全的方法来获取指针。（这样做将允许一种方法修改接口内部值的内容，而这是语言规范所不允许的。）

即使在编译器可以将值的地址传递给方法的情况下，如果方法修改了该值，则更改也将在调用方中丢失。作为一个例子，如果该`Write`方法 [`bytes.Buffer`](https://golang.org/pkg/bytes/#Buffer) 中使用的值接收器，而不是一个指针，这样的代码：

```
var buf bytes.Buffer
io.Copy（buf，os.Stdin）
```

将标准输入复制到的*副本*中`buf`，而不是*复制*到`buf`自身中。这几乎从来不是期望的行为。

### 作为goroutines运行的闭包会发生什么？

当使用并发闭包时可能会引起一些混乱。考虑以下程序：

```
func main（）{
    完成：= make（chan bool）

    值：= [] string {“ a”，“ b”，“ c”}
    对于_，v：=范围值{
        go func（）{
            fmt.Println（v）
            完成<-正确
        }（）
    }

    //等待所有goroutine完成后再退出
    对于_ =范围值{
        <-完成
    }
}
```

一个人可能会错误地期望将其`a, b, c`视为输出。您可能会看到的是`c, c, c`。这是因为循环的每次迭代都使用变量的相同实例`v`，因此每个闭包都共享该单个变量。当封闭运行，它打印的价值`v`的时候`fmt.Println`被执行，但`v`可能已经被修改，因为够程推出。为了帮助在此问题和其他问题发生之前进行检测，请运行 [`go vet`](https://golang.org/cmd/go/#hdr-Run_go_tool_vet_on_packages)。

要将当前值绑定`v`到每个闭包启动时，必须修改内部循环以在每次迭代时创建一个新变量。一种方法是将变量作为参数传递给闭包：

```
    对于_，v：=范围值{
        go func（u string）{
            fmt.Println（u）
            完成<-正确
        }（v）
    }
```

在此示例中，的值`v`作为参数传递给匿名函数。然后可以在函数内部将其作为变量访问`u`。

使用声明样式似乎更奇怪，但是在Go中可以正常工作，这甚至更容易：

```
    对于_，v：=范围值{
         v：= v //创建一个新的'v'。
        go func（）{
            fmt.Println（v）
            完成<-正确
        }（）
    }
```

回想起来，这种语言的行为（未为每次迭代定义新的变量）可能是一个错误。可能会在更高版本中解决，但出于兼容性考虑，在Go版本1中无法更改。

## 控制流

### 为什么Go没有`?:`操作员？

Go中没有三元测试操作。您可以使用以下方法获得相同的结果：

```
如果expr {
    n =真值
} 别的 {
    n = falseVal
}
```

`?:`Go缺席 的原因是该语言的设计人员发现该操作过于频繁地用于创建难以理解的复杂表达式。的`if-else`形式，虽然较长，无疑是更清晰。一种语言仅需要一个条件控制流构造。

## 包装和测试

### 如何创建多文件包？

将软件包的所有源文件自己放在一个目录中。源文件可以随意引用不同文件中的项目。不需要前向声明或头文件。

除了分成多个文件之外，该程序包还将像单文件程序包一样进行编译和测试。

### 如何编写单元测试？

`_test.go`在与包源相同的目录中 创建一个新文件。在该文件中，`import "testing"` 并编写表单的函数

```
func TestFoo（t * testing.T）{
    ...
}
```

`go test`在该目录中 运行。该脚本查找`Test`功能，构建测试二进制文件并运行它。

有关更多详细信息，请参见“[如何编写Go代码”](https://golang.org/doc/code.html)文档，[`testing`](https://golang.org/pkg/testing/)软件包和[`go test`](https://golang.org/cmd/go/#hdr-Test_packages)子命令。

### 我最喜欢的帮助程序功能在哪里？

Go的标准[`testing`](https://golang.org/pkg/testing/)软件包使编写单元测试变得容易，但是缺少其他语言的测试框架提供的功能，例如断言功能。在[前面一节](https://golang.org/doc/faq#assertions)本文件的解释了为什么Go没有断言，和相同的论点也适用于使用`assert`的测试。正确的错误处理意味着在一个测试失败后再运行其他测试，以便调试该故障的人可以全面了解问题所在。对于报告`isPrime`为2、3、5和7（或对于2、4、8和16）给出错误答案的测试，比报告为错误的测试更为有用。 `isPrime`给出2的错误答案，因此不再运行测试。触发测试失败的程序员可能不熟悉失败的代码。现在，在测试中断后，花费大量时间编写一条良好的错误消息即可获得回报。

与此相关的一点是，测试框架趋向于发展成具有条件，控件和打印机制的自己的微型语言，但是Go已经具备了所有这些功能。为什么要重新创建它们？我们宁愿用Go编写测试；它是一种要学习的语言，而且这种方法使测试简单明了且易于理解。

如果编写良好错误所需的额外代码量似乎是重复性的和压倒性的，则在表驱动，迭代数据结构中定义的输入和输出列表的情况下，该测试可能会更好（Go对数据结构字面量提供了出色的支持）。编写好的测试和好的错误消息的工作将在许多测试用例中分摊。标准的Go库充满了说明性示例，例如在 [包](https://golang.org/src/fmt/fmt_test.go)[的格式测试中`fmt`](https://golang.org/src/fmt/fmt_test.go)。

### 为什么*X*在标准库中不存在？

标准库的目的是支持运行时，连接到操作系统并提供许多Go程序所需的关键功能，例如格式化的I / O和联网。它还包含对Web编程重要的元素，包括加密和对HTTP，JSON和XML等标准的支持。

没有明确的标准来定义所包含的内容，因为长期以来，这是*唯一的*Go库。但是，有一些标准定义了今天要添加的内容。

标准库中很少有新的内容，包含的标准也很高。标准库中包含的代码承担大量持续的维护成本（通常由原作者以外的人承担），并受[Go 1兼容性承诺的](https://golang.org/doc/go1compat.html)约束 （阻止对API中任何缺陷的修复），并受Go[发布的](https://golang.org/s/releasesched)约束 [schedule](https://golang.org/s/releasesched)，防止用户快速获得错误修复。

大多数新代码应位于标准库之外，并且可以通过该[`go`工具](https://golang.org/cmd/go/)的 `go get`命令进行访问。这样的代码可以有自己的维护者，发布周期和兼容性保证。用户可以在[godoc.org上](https://godoc.org/)找到软件包并阅读其文档 。

尽管标准库中有一些并不真正属于的部分，例如`log/syslog`，由于Go 1兼容性的承诺，我们继续维护库中的所有内容。但是，我们鼓励将大多数新代码放在其他地方。

## 执行

### 编译器使用什么编译器技术？

有几种用于Go的生产编译器，还有许多正在为各种平台开发的编译器。

默认的编译器`gc`包含在Go发行版中，作为`go` 命令支持的一部分。 `Gc`由于引导困难，它最初是用C编写的-您需要Go编译器来设置Go环境。但是事情发展了，自Go 1.5发行以来，编译器一直是Go程序。如本[设计文档](https://golang.org/s/go13compiler) 和[talk中](https://talks.golang.org/2015/gogo.slide#1)所述，使用自动翻译工具将编译器从C转换为Go 。因此，编译器现在是“自托管”的，这意味着我们需要面对引导问题。解决方案是已经有一个可以正常运行的Go安装，就像正常情况下可以正常工作的C安装一样。如何打开来自源的新进入环境中的故事描述[在这里](https://golang.org/s/go15bootstrap)和 [这里](https://golang.org/doc/install/source)。

`Gc` 是使用Go编写的，带有递归下降解析器，并且使用了也是用Go编写但基于Plan 9加载程序的自定义加载程序来生成ELF / Mach-O / PE二进制文件。

在项目开始时，我们考虑使用LLVM， `gc`但认为它太大且太慢，无法满足我们的性能目标。回顾起来更重要的是，从LLVM开始会使Go引入但不是标准C设置的一部分的ABI和相关更改（例如堆栈管理）变得更加困难。但是，新的[LLVM实施](https://go.googlesource.com/gollvm/) 现在开始出现。

所述`Gccgo`编译器是一个前端用C ++编写与耦合到标准GCC后端的递归下降语法分析器。

事实证明，使用Go语言是实现Go编译器的一种很好的语言，尽管这并不是其最初的目标。从一开始就没有自我托管功能，Go的设计就可以专注于最初的用例，即网络服务器。如果我们决定Go应该尽早进行编译，那么我们可能最终会使用一种针对更多编译器构造的语言，这是一个值得的目标，但不是我们最初的目标。

尽管`gc`不使用它们（还？），但[`go`](https://golang.org/pkg/go/)软件包中提供了本机词法分析器和解析器，并且还提供了本机[类型检查器](https://golang.org/pkg/go/types)。

### 如何实现运行时支持？

再次由于引导问题，运行时代码最初主要是用C编写的（只有少量汇编程序），但此后已转换为Go（某些汇编程序位除外）。 `Gccgo`的运行时支持使用`glibc`。该`gccgo`编译器实现够程使用一种叫做分段栈技术，最近修改的金连接器的支持。 `Gollvm`类似地建立在相应的LLVM基础架构上。

### 为什么我的琐碎程序这么大的二进制文件？

`gc`默认情况下 ，工具链中的链接器会创建静态链接的二进制文件。因此，所有Go二进制文件都包含Go运行时，以及支持动态类型检查，反射甚至紧急时间堆栈跟踪所必需的运行时类型信息。

在Linux上使用gcc静态编译并静态链接的一个简单的C“ hello，world”程序约为750 kB，其中包括的实现 `printf`。等效的Go程序使用的 `fmt.Printf`重量为几兆字节，但是其中包括更强大的运行时支持以及类型和调试信息。

`gc`可以将用 编译的Go程序与该`-ldflags=-w`标志链接以禁用DWARF生成，从而从二进制文件中删除调试信息，但不会造成其他功能损失。这可以大大减小二进制大小。

### 我可以停止对未使用的变量/导入的投诉吗？

未使用的变量的存在可能表示错误，而未使用的导入只会减慢编译的速度，随着程序随着时间的推移积累代码和程序员，这种影响会变得很明显。由于这些原因，Go拒绝使用未使用的变量或导入来编译程序，为了短期的构建速度和程序的清晰性而使用短期的便利性。

但是，在开发代码时，通常会临时创建这些情况，并且在程序编译之前必须将它们进行编辑可能会很烦人。

有些人要求使用编译器选项来关闭这些检查或至少将其减少为警告。不过，由于编译器选项不应影响语言的语义，并且因为Go编译器不报告警告，因此仅添加阻止编译的错误，因此未添加该选项。

没有警告有两个原因。首先，如果值得抱怨，则值得在代码中进行修复。（并且，如果不值得修复，就不值得一提。）其次，让编译器生成警告可鼓励实现对可能会使编译产生噪音的弱情况发出警告，从而掩盖了*应*修复的实际错误 。

不过，解决这种情况很容易。使用空白标识符可以在开发过程中使未使用的东西持久化。

```
导入“未使用”

//此声明通过引用
//包中的商品。
var _ =未使用。Item// TODO：在提交之前删除！

func main（）{
    debugData：= debug.Profile（）
    _ = debugData //仅在调试期间使用。
    ....
}
```

如今，大多数Go程序员都使用[goimports](https://godoc.org/golang.org/x/tools/cmd/goimports)工具，该工具 会自动重写Go源文件以具有正确的导入，从而消除了实践中未使用的导入问题。编写Go源文件时，该程序可轻松连接到大多数编辑器，以自动运行。

### 为什么我的病毒扫描软件认为我的Go发行版或编译的二进制文件已被感染？

这是常见的现象，尤其是在Windows计算机上，并且几乎总是假阳性。商业病毒扫描程序经常被Go二进制文件的结构所迷惑，它们看起来不像其他语言编译的那样频繁。

如果您刚刚安装了Go发行版，并且系统报告它已被感染，那肯定是一个错误。确实，您可以通过将校验和与[下载页面](https://golang.org/dl/)上的校验和进行比较来验证 [下载](https://golang.org/dl/)。

无论如何，如果您认为报告错误，请向病毒扫描程序的供应商报告错误。也许及时病毒扫描程序可以学习理解Go程序。

## 表现

### 为什么Go在基准X上表现不佳？

Go的设计目标之一是使C的性能达到可比程序的水平，但在某些基准测试中，它的性能却很差，包括[golang.org/x/exp/shootout中的](https://go.googlesource.com/exp/+/master/shootout/)一些基准。最慢的速度取决于在Go中没有可比较性能的版本的库。例如，[pidigits.go](https://go.googlesource.com/exp/+/master/shootout/pidigits.go) 依赖于一个多精度数学包，而与Go语言不同，C版本使用[GMP](https://gmplib.org/)（用优化的汇编器编写）。依赖于正则表达式的基准（例如[regex-dna.go](https://go.googlesource.com/exp/+/master/shootout/regex-dna.go)）实际上将Go的本地正则[表达式软件包](https://golang.org/pkg/regexp)与成熟的，高度优化的正则表达式库（如PCRE）进行了比较。

基准测试通过广泛的调整赢得了胜利，大多数基准的Go版本需要引起注意。如果您测量可比较的C和Go程序（[reverse-complement.go](https://go.googlesource.com/exp/+/master/shootout/reverse-complement.go) 是一个示例），您会发现这两种语言的原始性能比该套件所表明的更加接近。

尽管如此，仍有改进的空间。编译器很好，但可能会更好，许多库需要主要的性能工作，而且垃圾收集器还不够快。（即使是这样，注意不要产生不必要的垃圾也会产生巨大的影响。）

在任何情况下，Go往往都具有很高的竞争力。随着语言和工具的发展，许多程序的性能有了显着提高。有关信息示例，请参阅有关[对Go程序](https://blog.golang.org/2011/06/profiling-go-programs.html)进行[概要分析](https://blog.golang.org/2011/06/profiling-go-programs.html)的博客文章 。

## 从C的变化

### 为什么语法与C如此不同？

除了声明语法以外，差异不是主要的，并且源自两个愿望。首先，语法应该轻巧，没有太多的强制性关键字，重复或奥秘。其次，该语言的设计易于分析，无需符号表即可进行分析。这使构建工具（例如调试器，依赖分析器，自动文档提取器，IDE插件等）变得更加容易。在这方面，C及其后代非常困难。

### 为什么声明向后？

如果您习惯使用C，它们只会倒退。在C中，概念是声明变量就像表示其类型的表达式一样，这是一个不错的主意，但是类型和表达式语法混合得并不好，并且结果可能令人困惑；考虑函数指针。Go大多将表达式和类型语法分开，并简化了事情（使用前缀`*`作为指针是证明规则的例外）。在C中，声明

```
    int * a，b;
```

声明`a`是一个指针，但不是`b`；在围棋

```
    var a，b * int
```

声明两个都是指针。这更清晰，更规则。此外，`:=`短申报表认为，一个完整的变量声明应呈现相同的顺序`:=`，从而

```
    var a uint64 = 1
```

与...具有相同的效果

```
    一个：= uint64（1）
```

通过对类型具有独特的语法（不仅是表达语法），还可以简化解析。之类的关键字，`func` 并`chan`保持清晰。

有关 更多详细信息，请参见有关[Go的声明语法](https://golang.org/doc/articles/gos_declaration_syntax.html)的文章 。

### 为什么没有指针算术？

安全。如果没有指针算术，就有可能创建一种永远不会派生出不正确地址的语言。编译器和硬件技术已经发展到可以使用数组索引的循环与使用指针算术的循环一样高效的地步。同样，缺少指针算法可以简化垃圾回收器的实现。

### 为什么`++`和`--`语句而不是表达式？为什么是后缀而不是前缀？

如果不使用指针算法，则前缀和后缀增量运算符的便利性值会下降。通过将它们从表达式层次结构中完全删除，可以简化表达式语法，`++`并且还消除了围绕和`--` （考虑`f(i++)`和`p[i] = q[++i]`）的求值顺序的混乱问题。简化意义重大。至于后缀和前缀，两者都可以正常工作，但后缀版本更传统。STL是对语言前缀的坚持，STL是一种语言库，具有讽刺意味的是其名称包含后缀增量。

### 为什么有花括号但没有分号？为什么我不能在下一行放开括号？

Go使用括号括起来进行语句分组，这是使用C系列中任何语言的程序员所熟悉的语法。但是，分号用于解析器，而不用于人员，我们希望尽可能地消除它们。为了实现此目标，Go借用了BCPL的技巧：分离语句的分号在形式语法中，但由词法分析器在可能是语句结尾的任何行的末尾自动注入，而不会提前。这在实践中效果很好，但具有强制使用大括号样式的效果。例如，函数的右括号不能单独出现在一行上。

有人认为，词法分析器应提前做准备，以使花括号位于下一行。我们不同意。由于Go代码是由自动格式化的 [`gofmt`](https://golang.org/cmd/gofmt/)，因此 必须选择*某种*样式。该样式可能与您在C或Java中使用的样式有所不同，但是Go是另一种语言，并且 `gofmt`的样式与其他样式一样好。更重要的是，对于所有Go程序而言，单一的，由程序授权的格式的优点都大大超过了特定样式的任何可察觉的缺点。还要注意，Go的样式意味着Go的交互式实现可以一次使用标准语法，而无需特殊规则。

### 为什么要进行垃圾收集？会不会太贵？

系统程序中簿记的最大来源之一是管理分配对象的生存期。在像C这样的语言中，它是手动完成的，因此可能会消耗大量的程序员时间，并且通常是造成有害错误的原因。即使使用提供帮助机制的C ++或Rust这样的语言，这些机制也可能对软件的设计产生重大影响，通常会增加其自身的编程开销。我们认为消除此类程序员的开销至关重要，并且近几年来垃圾收集技术的进步使我们充满信心，认为它可以以足够便宜的方式实现，并具有足够低的延迟，这对于网络系统而言可能是一种可行的方法。

并发编程的许多困难都源于对象生存期问题：当对象在线程之间传递时，要确保它们安全地释放就变得很麻烦。自动垃圾收集使并发代码更容易编写。当然，在并发环境中实现垃圾回收本身就是一个挑战，但是一次完成而不是在每个程序中都可以帮助所有人。

最后，撇开并发性，垃圾回收使接口更简单，因为它们不需要指定如何管理接口间的内存。

这并不是说最近在Rust之类的语言上进行的工作为新思想带来了错误的管理；我们鼓励这项工作，并很高兴看到它的发展。但是Go采用了一种更传统的方法，即通过垃圾回收来解决对象生存期，而仅通过垃圾回收来解决。

当前的实现是标记清除收集器。如果机器是多处理器，则收集器在与主程序并行的单独CPU内核上运行。近年来，收集器上的主要工作将暂停时间通常减少到了毫秒以下，即使对于大堆也是如此，几乎消除了对网络服务器中垃圾收集的主要反对之一。继续进行工作以完善算法，进一步减少开销和等待时间，并探索新方法。 Go团队的Rick Hudson在2018 [ISMM主题演讲中](https://blog.golang.org/ismmkeynote)描述了迄今为止的进展并提出了一些未来的方法。

关于性能主题，请记住，Go为程序员提供了对内存布局和分配的相当多的控制权，远远超过了垃圾收集语言中的典型控制权。精心设计的程序员可以很好地使用该语言，从而大大减少垃圾回收的开销。有关工作示例，请参阅有关[对Go程序](https://blog.golang.org/2011/06/profiling-go-programs.html)进行[概要分析](https://blog.golang.org/2011/06/profiling-go-programs.html)的文章 ，其中包括Go的概要分析工具的演示。