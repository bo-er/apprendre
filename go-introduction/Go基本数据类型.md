## 变量

Go 中使用`var`语句来声明一个变量列表，跟函数的参数列表一样，类型在最后。

比如声明一个可导出的 Name 变量:

```go
var Name string

```

### 变量的初始化

变量声明可以包含初始值，每个变量对应一个:

```go
var name,hobby string = "fool","eating"
```

如果初始化值已经存在，则可以省略类型，变量会从初始化值中获得类型:

```go
var name,hobby = "fool","eating"
```

### 短变量声明

在函数中，简洁赋值语句`:=`可在类型明确的地方替代 var 声明。

函数外的每个语句都必须以关键字开始(var func 等等),因此`:=`结构不能再函数外使用。

## 基本数据类型

### 整型

整型分为以下两个大类： 按长度分为：int8、int16、int32、int64 对应的无符号整型：uint8、uint16、uint32、uint64

其中，`uint8`就是我们熟知的`byte`型，`int16`对应 C 语言中的`short`型，`int64`对应 C 语言中的`long`型。

| 类型   | 描述                                                           |
| ------ | -------------------------------------------------------------- |
| uint8  | 无符号 8 位整型 (0 到 255)                                     |
| uint16 | 无符号 16 位整型 (0 到 65535)                                  |
| uint32 | 无符号 32 位整型 (0 到 4294967295)                             |
| uint64 | 无符号 64 位整型 (0 到 18446744073709551615)                   |
| int8   | 有符号 8 位整型 (-128 到 127)                                  |
| int16  | 有符号 16 位整型 (-32768 到 32767)                             |
| int32  | 有符号 32 位整型 (-2147483648 到 2147483647)                   |
| int64  | 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807) |

### 特殊整型

| 类型    | 描述                                                     |
| ------- | -------------------------------------------------------- |
| uint    | 32 位操作系统上就是`uint32`，64 位操作系统上就是`uint64` |
| int     | 32 位操作系统上就是`int32`，64 位操作系统上就是`int64`   |
| uintptr | 无符号整型，用于存放一个指针                             |

**注意：** 在使用`int`和 `uint`类型时，不能假定它是 32 位或 64 位的整型，而是考虑`int`和`uint`可能在不同平台上的差异。

**注意事项** 获取对象的长度的内建`len()`函数返回的长度可以根据不同平台的字节长度进行变化。实际使用中，切片或 map 的元素数量等都可以用`int`来表示。在涉及到二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用`int`和 `uint`。

### 数字字面量语法（Number literals syntax）

Go1.13 版本之后引入了数字字面量语法，这样便于开发者以二进制、八进制或十六进制浮点数的格式定义数字，例如：

`v := 0b00101101`， 代表二进制的 101101，相当于十进制的 45。 `v := 0o377`，代表八进制的 377，相当于十进制的 255。 `v := 0x1p-2`，代表十六进制的 1 除以 2²，也就是 0.25。

而且还允许我们用 `_` 来分隔数字，比如说： `v := 123_456` 表示 v 的值等于 123456。

我们可以借助 fmt 函数来将一个整数以不同进制形式展示。

```go
package main

import "fmt"

func main(){
	// 十进制
	var a int = 10
	fmt.Printf("%d \n", a)  // 10
	fmt.Printf("%b \n", a)  // 1010  占位符%b表示二进制

	// 八进制  以0开头
	var b int = 077
	fmt.Printf("%o \n", b)  // 77

	// 十六进制  以0x开头
	var c int = 0xff
	fmt.Printf("%x \n", c)  // ff
	fmt.Printf("%X \n", c)  // FF
}
```

## 浮点型

Go 语言支持两种浮点型数：`float32`和`float64`。这两种浮点型数据格式遵循`IEEE 754`标准： `float32` 的浮点数的最大范围约为 `3.4e38`，可以使用常量定义：`math.MaxFloat32`。 `float64` 的浮点数的最大范围约为 `1.8e308`，可以使用一个常量定义：`math.MaxFloat64`。

打印浮点数时，可以使用`fmt`包配合`%f`，代码如下：

```go
package main
import (
        "fmt"
        "math"
)
func main() {
        fmt.Printf("%f\n", math.Pi)
        fmt.Printf("%.2f\n", math.Pi)
}
```

## 复数

complex64 和 complex128

```go
var c1 complex64
c1 = 1 + 2i
var c2 complex128
c2 = 2 + 3i
fmt.Println(c1)
fmt.Println(c2)
```

复数有实部和虚部，complex64 的实部和虚部为 32 位，complex128 的实部和虚部为 64 位。

## 布尔值

Go 语言中以`bool`类型进行声明布尔型数据，布尔型数据只有`true（真）`和`false（假）`两个值。

**注意：**

1. 布尔类型变量的默认值为`false`。
2. Go 语言中不允许将整型强制转换为布尔型.
3. 布尔型无法参与数值运算，也无法与其他类型进行转换。

## 字符串

Go 语言中的字符串以**原生数据类型**出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。 Go 语言里的字符串的内部实现使用`UTF-8`编码。 字符串的值为`双引号(")`中的内容，可以在 Go 语言的源码中直接添加非 ASCII 码字符，例如：

```go
s1 := "hello"
s2 := "你好"
```

字符串的初始值是**""**而不是 nil

```go
    var s string
    println( s == "" )  //true
    println( s == nil ) //invalid operation: s == nil (mismatched types string and nil)
```

### 字符串转义符

Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等，如下表所示。

| 转义符 | 含义                               |
| ------ | ---------------------------------- |
| `\r`   | 回车符（返回行首）                 |
| `\n`   | 换行符（直接跳到下一行的同列位置） |
| `\t`   | 制表符                             |
| `\'`   | 单引号                             |
| `\"`   | 双引号                             |
| `\\`   | 反斜杠                             |

举个例子，我们要打印一个 Windows 平台下的一个文件路径：

```go
package main
import (
    "fmt"
)
func main() {
    fmt.Println("str := \"c:\\Code\\lesson1\\go.exe\"")
}
```

### 多行字符串

Go 语言中要定义一个多行字符串时，就必须使用`反引号`字符：

```go
s1 := `第一行
第二行
第三行
`
fmt.Println(s1)
```

反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。

例子:

双引号之间的转义符会被转义，而反引号之间的转义符保持不变。双引号不支持跨行代码，而反引号支持。

```go
{
    println("hello\tgo")    //输出hello    go
    println(`hello\tgo`)    //输出hello\tgo
}

{
    println( "hello
    go" )//syntax error: unexpected semicolon or newline, expecting comma or )

    println(`hello
        go`) //可以编译通过
}
输出
hello
    go
```

### 字符串的常用操作

| 方法                                | 介绍           |
| ----------------------------------- | -------------- |
| len(str)                            | 求长度         |
| +或 fmt.Sprintf                     | 拼接字符串     |
| strings.Split                       | 分割           |
| strings.contains                    | 判断是否包含   |
| strings.HasPrefix,strings.HasSuffix | 前缀/后缀判断  |
| strings.Index(),strings.LastIndex() | 子串出现的位置 |
| strings.Join(a[]string, sep string) | join 操作      |

### 格式化输出的占位符

|            动 词 |                                        功 能 | 例子                            | 输出                     |
| ---------------: | -------------------------------------------: | ------------------------------- | ------------------------ |
|               %v |                             按值的本来值输出 | Printf("%v",people)             | {Steve}                  |
|              %+v |     在 %v 基础上，对结构体字段名和值进行展开 | Printf("%+v",people)            | {Name:Steve}             |
|              %#v |                     输出 Go 语言语法格式的值 | Printf("%#v",people)            | main.Human{Name:"Steve"} |
|               %T |               输出 Go 语言语法格式的类型和值 | Printf("%T",people)             | main.Human               |
|               %% |                                输出 % 字面值 | Printf("%%")                    | %                        |
|       整数占位符 |                                              |                                 |                          |
|               %b |                         整型以二进制方式显示 | Printf("%b",5)                  | 101                      |
|               %o |                         整型以八进制方式显示 | Printf("%o",10)                 | 12                       |
|               %d |                         整型以十进制方式显示 | Printf("%o",0x12)               | 18                       |
|               %x |          整型以十六进制方式显示,字母形式小写 | Printf("%x",13)                 | d                        |
|               %X |          整型以十六进制方式显示,字母形式大写 | Printf("%x",13)                 | D                        |
|               %q | 单引号围绕的字符字面值，由 go 语法安全地转义 | Printf("%q",0X4E2D)             | '中'                     |
|               %c |                    输出 Unicode 所表示的字符 | Printf("%c",0x4E2D)             | 中                       |
|               %U |          Unicode 格式: U+1234,等同于"U+%04X" | Printf("%U",0x4E2D)             | U+4E2D                   |
| 字符串与字节切片 |                                              |                                 |                          |
|               %s |        输出字符串表示(string 类型或者[]byte) | Printf("%s",[ ]byte("GO 语言")) | GO 语言                  |
|               %q |     双引号围绕的字符串，由 GO 语法安全地转义 | Printf("%q","GO 语言")          | "GO 语言"                |
|               %x |     转为 16 进制，小写字母，每个字节两个字符 | Printf("%x","golang")           | 676f6c616e67             |
|               %X |     转为 16 进制，大写字母，每个字节两个字符 | Printf("%x","golang")           | 676F6C616E67             |
|             指针 |                                              |                                 |                          |
|               %p |                    以 16 进制表示，前缀为 0x |                                 |                          |
|     浮点数与复数 |                                              |                                 |                          |
|               %f |               有小数点而无指数，比如 123.456 | Printf("%f",10.2)               | 10.200000                |

## byte 和 rune 类型

组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来，如：

```go
var a := '中'
var b := 'x'
```

Go 语言的字符有以下两种：

1. `uint8`类型，或者叫 byte 型，代表了`ASCII码`的一个字符。
2. `rune`类型，代表一个 `UTF-8字符`。

当需要处理中文、日文或者其他复合字符时，则需要用到`rune`类型。`rune`类型实际是一个`int32`。

Go 使用了特殊的 rune 类型来处理 Unicode，让基于 Unicode 的文本处理更为方便，也可以使用 byte 型进行默认字符串处理，性能和扩展性都有照顾。

Go 字符串允许用索引号访问字节数组(区分字符)但不能获取元素的地址比如

```go
    {
        var a = "hello"
        println(a[0])       //输出 104
        println(&a[1])      //cannot take the address of a[1]
    }
```

使用传统的 for i 循环遍历的是字节数组(不是字符), 而使用 for range 循环遍历的是字符

例子：

```go
// 遍历字符串
func traversalString() {
	s := "hello世界"
  //以byte方式按字节遍历
  //byte %c输出单个字节
	for i := 0; i < len(s); i++ {
		fmt.Printf("%v(%c) ", s[i], s[i])
	}
	fmt.Println()
  //以rune方式遍历
	for _, r := range s {
		fmt.Printf("%v(%c) ", r, r)
	}
	fmt.Println()
}
```

输出：

```go
104(h) 101(e) 108(l) 108(l) 111(o) 228(ä) 184(¸) 150() 231(ç) 149() 140()
104(h) 101(e) 108(l) 108(l) 111(o) 19990(世) 30028(界)
```

因为 UTF8 编码下一个中文汉字由 3~4 个字节组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果。

在 Go 语言中字符串的底层使用不可以改变的 byte 数组存储。所以在用 byte 遍历方式时每次得到的只有一个 byte，而中文字符则是占 3 个 byte 的。rune 采用计算字符串长度的方式与 byte 方式不同比如

字符串底层是一个 byte 数组，所以可以和`[]byte`类型相互转换。字符串是不能修改的 字符串是由 byte 字节组成，所以字符串的长度是 byte 字节的长度。 rune 类型用来表示 utf8 字符，一个 rune 字符由一个或多个 byte 组成。

如果想要使用 for i 循环又是以字符遍历，可以先将字符串转化为 rune 切片，再使用内置 len 函数计算长度。

### 修改字符串

要修改字符串，需要先将其转换成`[]rune`或`[]byte`，完成后再转换为`string`。无论哪种转换，都会重新分配内存，并复制字节数组。

```go
func changeString() {
	s1 := "big"
	// 强制类型转换
	byteS1 := []byte(s1)
	byteS1[0] = 'p'
	fmt.Println(string(byteS1))

	s2 := "白萝卜"
	runeS2 := []rune(s2)
	runeS2[0] = '红'
	fmt.Println(string(runeS2))
}
```

## 类型转换

Go 语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。

强制类型转换的基本语法如下：

```bash
T(表达式)
```

其中，T 表示要转换的类型。表达式包括变量、复杂算子和函数返回值等.

比如计算直角三角形的斜边长时使用 math 包的 Sqrt()函数，该函数接收的是 float64 类型的参数，而变量 a 和 b 都是 int 类型的，这个时候就需要将 a 和 b 强制类型转换为 float64 类型。

```go
func sqrtDemo() {
	var a, b = 3, 4
	var c int
	// math.Sqrt()接收的参数是float64类型，需要强制转换
	c = int(math.Sqrt(float64(a*a + b*b)))
	fmt.Println(c)
}
```

## 类型推导

在声明一个变量而不指定其类型时（即使用不带类型的 := 语法或 var = 表达式语法），变量的类型由右值推导得出。

当右值声明了类型时，新变量的类型与其相同：

```go
var i int
j := i // j 也是一个 int
```

不过当右边包含未指明类型的数值常量时，新变量的类型就可能是 int, float64 或 complex128 了，这取决于常量的精度：

```go
i := 42           // int
f := 3.142        // float64
g := 0.867 + 0.5i // complex128
```

尝试修改示例代码中 v 的初始值，并观察它是如何影响类型的。
