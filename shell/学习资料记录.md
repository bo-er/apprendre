## What's the difference between <<, <<< and < < in bash?

[full anmswer](https://askubuntu.com/questions/678915/whats-the-difference-between-and-in-bash/678919#678919)

- << is known as here-document structure. You let the program know what will be the ending text, and whenever that delimiter is seen, the program will read all the stuff you've given to the program as input and perform a task upon it.

- <<< is known as here-string . Instead of typing in text, you give a pre-made string of text to a program.

- Process Substitution

As tldp.org explains,

Process substitution feeds the output of a process (or processes) into the stdin of another process.

So in effect this is similar to piping stdout of one command to the other , e.g.

```
echo foobar barfoo | wc
```

But notice: in the bash manpage you will see that it is denoted as `<(list)`. So basically you can redirect output of multiple (!) commands.

> Note: technically when you say < < you aren't referring to one thing, but two redirections with single < and process redirection of output from <( . . .).

Now what happens if we do just process substitution?

$ echo <(echo bar)

```
/dev/fd/63
```

As you can see, the shell creates temporary file descriptor `/dev/fd/63` where the output goes (which according to Gilles's answer, is an anonymous pipe). That means < redirects that file descriptor as input into a command.

So very simple example would be to make process substitution of output from two echo commands into wc:
```
$ wc < <(echo bar;echo foo)
2 2 8
```
So here we make shell create a file descriptor for all the output that happens in the parenthesis and redirect that as input to wc .As expected, wc receives that stream from two echo commands, which by itself would output two lines, each having a word, and appropriately we have 2 words, 2 lines, and 6 characters plus two newlines counted.

How is process substitution implemented ? We can find out using the trace below (output shortened for brevity)
