### 判断语句if

- 条件表达式没有括号(if 后面没有括号)

- 支持一个初始化表达式（可以是并行方式）

  ```go
  
  func main(){
    //外部的a在if语句块里将被隐藏
    a := 2
    //a只能这样简写
    if a := 1; a >2{
  
  	}
    //也可以声明多个
    if a,b := 2,3; a>3{
      
    }
  }
  
  
  ```

  

- 左大括号必须和条件语句或者else在同一行

- 支持单行模式

- 初始化语句中的变量为block级别，同时隐藏外部同名变量

### 循环语句for

- 无限循环

  ```go
  func main(){
  	a := 1
  	//没有条件是无限循环
  	for{
  		//go 中 ++ --都只能单独一行使用
  		a++
  		if a > 3{
  			break
  		}
  	}
  
  }
  ```

  

- 有条件循环

  ```go
  func main(){
  	a := 1
  	//有条件的循环
  	for a <=3 {
  		//go 中 ++ --都只能单独一行使用
  		a++
  	}
  }
  ```

  

- 三段形式( i = ; i < ; i++ )

  ```go
  func main(){
  	a := 1
  	//没有条件是无限循环
  	for i=0 ;i < 3; i++{
  		//go 中 ++ --都只能单独一行使用
  		a++
  		if a > 3{
  			break
  		}
  	}
  
  }
  ```

### SWITCH语句

- 可以使用任何类型或者表达式作为条件语句
- 不需要写break, 一旦条件符合自动终止
- 如果希望继续执行下一个case,需要使用fallthrough语句
- 支持一个初始化表达式（可以是并行方式），右侧需要跟分号
- 左大括号必须和条件语句在同一行

```go
func main(){
	a := 1
	switch a{
		case 0:
			fmt.Println("a=0")
		case 1:
    	fmt.Println("a=1")
    default:
    	fmt.Println("a is uknown")
	}
	fmt.Println(a)
}
```

```go
func main(){
	a := 1
  //如果没有在switch后面写表达式那么case后面就要跟表达式了
	switch{
		case a >= 0:
			fmt.Println("a=0")
			fallthrough
		case a >= 1:
    	fmt.Println("a=1")
	}
	fmt.Println(a)
}
```

```go
func main(){
	swaitch a := 1;{
		case a >= 0:
			fmt.Println("a=0")
		case a >= 1:
    	fmt.Println("a=1")
	}
	fmt.Println(a)
}
```

### 跳转语句

- switch的三种语法都可以配合标签使用

- 标签名区分大小写，若不使用会造成编译错误

- Break和Continue配合标签可用于多层循环的跳出

- Goto是调整执行位置，与其他两个语句配合标签的结果并不相同

  ```go
  func main(){
  	LABEL1:
  		for{
        for i := 0;i<3;i++{
  				if i == 2{
  					//break只能跳出内层循环，无限循环仍然会进行下去
  					break
  				}
  			}
  		}
  }
  ```

  

break加上标签则可以跳出外层循环

```go
func main(){
	LABEL1:
		for{
      for i := 0;i<3;i++{
				if i == 2{
					//break跳出多层循环
					break LABEL1
				}
			}
		}
  fmt.Println("我出来啦！")
}
```

将break改成goto可以吗？ 答案是否定的，goto调整的是执行位置，如果goto  LABEL1那么会再次进入循环

使用goto的话标签要放到goto之后

```go
func main(){
	
		for{
      for i := 0;i<3;i++{
				if i == 2{
					//标签在goto之后，可以实现跳出循环的目的
					goto LABEL1
				}
			}
		}
	LABEL1:	
  fmt.Println("我出来啦！")
}
```

continue的使用

如果不带标签continue的意思是进入下一次循环

```go
func main(){
	LABEL1:
		for{
      for i := 0;i<3;i++{
				if i == 2{
					//继续执行LABEL1的循环
					continue LABEL1
				}
			}
		}
  fmt.Println("我出来啦！")
}
```

continue可以使用在无限循环中，使用在无限循环内部的有限循环是没用的。

```go
func main(){
	LABEL1:
      for i := 0;i<3;i++{
				for {
          //一进入无限循环立刻跳转到for的有限循环
					continue LABEL1
          //下面的语句永远不会打印
          fmt.Println("我不能被执行")
			  }
		}
  fmt.Println("我出来啦！")
}
```

上面的代码如果将continue换成goto是不行的，因为goto每次跳转i都会重置，这样相当于处在死循环中