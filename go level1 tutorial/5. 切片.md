### 切片的特点

- 切片本身不是数组，但是它指向底层的数组

- 作为变长数组的替代方案，可以关联底层数组的局部或者全部

- 切片是一个引用类型

- 可以直接创建或者从底层数组获取生成

- 使用 Len( )获取**元素个数**，cap( )获取**最大容量**

- 一般使用 make 来创建切片

- 如果多个切片指向相同的底层数组，其中一个切片的改变会影响全部

  **make ([ ]T,len,cap)**

  其中 cap 可以省略，省略后则是 len 的值

  len 表示存储的元素个数，cap 表示容量

问题：

1. 为什么不用 new 创建？

   因为 slice 本身就是一个指针，使用 new 通常是分配内存而不是指针的创建。

CODE PLAYGROUND 🎃

```go
var s1 []int
a := [10]int{}
//取数组中索引为9的切片
s2 := a[9]
//取数组中索引为5到9的切片（5到10不包含10）
s3 := a[5:10]
//取前5个元素
s4 := a[:5]
//取后5个元素
s5 := a[5:]
```

切片虽然是变长的，但是我们可以给他设置初始容量

```go
//给一小块能容纳10个元素的内存，只要元素数量不超过10个就不需要开辟新的内存空间
s1 := make([]int,3,10)
//如果不指定初始容量那么容量就是切片长度
s2 := make([]int,3)
```

切片切取数组的一段，但是它的容量包含了切下来的数组之后的部分

```go
func main(){
	a := []byte{'a','b','c','d','e','f','g'}
	sa := a[2:5]

	//打印结果为：3 5
	fmt.Println(len(sa),cap(sa))

	//打印结果为[99 100 101 102 103]
	fmt.Println(sa[:5])
}
```

​ 就像下图中切片后面的尾巴 半透明的格子所示，切片的最大容量包括了底层数组未切过来的长度![](/Users/steve/Documents/GIT/apprendre/pictures/go-lang/sliceOfArray.png)

### 再切片

- 二次切片时索引以切片为准
- 索引不可以超过被切片的切片容量 cap( )得到的值
- 索引越界不会导致底层数组的重新分配而是会引发错误

### 往切片添加元素

- 可以在切片尾部追加元素
- 可以将一个切片追加在另外一个切片尾部
- 如果最终长度未超过追加到切片的容量则返回原始的切片
- 如果最终长度超过追加到切片的容量则将**重新分配数组并且拷贝原始数据**

```go
func main(){
	a := []byte{'a','b','c','d','e','f','g'}
	sa := a[2:]
	fmt.Printf("%v,%p\n",sa,sa)
	sa = append(sa, 'h','i','j','k')
	fmt.Printf("%v,%p",sa,sa)
}
//由于超过了原始数组的容量，
[99 100 101 102 103],0xc000016082
[99 100 101 102 103 104 105 106 107],0xc0000160a0

```

再看下面的代码：

```go
	a := []byte{'a','b','c','d','e','f','g'}
	sa := a[2:]
	fmt.Printf("%v,%p\n",sa,sa)
	//执行append由于超过了原始数组的长度，此时计算机将生成一个新的数组，
	//并且将a的内容全部复制到新数组
	a = append(sa, 'h','i','j','k')
	fmt.Printf("%v,%p\n",sa,sa)
	//sa的改变不影响原始数组a
	sa[0] = 'w'
	fmt.Printf("%v,%p",a,a)

    //打印结果为：
    [99 100 101 102 103],0xc000016082
    [99 100 101 102 103 104 105 106 107],0xc0000160a0
    [97 98 99 100 101 102 103],0xc000016080

```

但是如果是改变了 sa[0] = 'w'的位置：

```go
	a := []byte{'a','b','c','d','e','f','g'}
	sa := a[2:]
	sa[0] = 'w'
	fmt.Printf("%v,%p\n",sa,sa)
	sa = append(sa, 'h','i','j','k')
	fmt.Printf("%v,%p\n",sa,sa)
	fmt.Printf("%v,%p",a,a)

	//打印结果为：
	[119 100 101 102 103],0xc0000b4004
	[119 100 101 102 103 104 105 106 107],0xc0000b4030
	//原数组a的第3个元素变成了119
	[97 98 119 100 101 102 103],0xc0000b4002

```

### 复制函数 copy

```go
func main(){
	s1 := []int{1,2,3,4,5,6}
	s2 := []int{7,8,9}
	//s2 --copy--> s1
	//s1 is:  [7 8 9 4 5 6]
	//s2 is:  [7 8 9]

	copy(s1,s2)

	fmt.Println("s1 is: ",s1)
	fmt.Println("s2 is: ",s2)
}
```

```go
func main(){
	s1 := []int{1,2,3,4,5,6}
	s2 := []int{7,8,9}
	//s2 --copy--> s1
	//s1 is:  [1 2 3 4 5 6]
	//s2 is:  [1 2 3]

	copy(s2,s1)

	fmt.Println("s1 is: ",s1)
	fmt.Println("s2 is: ",s2)
}
```
