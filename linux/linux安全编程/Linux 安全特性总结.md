## 3. Linux 安全特性总结

在讨论有关如何使用 Linux 安全功能的指南之前，从程序员的角度了解这些功能是什么很有用。本节简要介绍这些功能；如果您已经知道这些功能是什么，请随时跳过本节。

许多编程指南都简要介绍了 Linux 与安全相关的部分，并跳过了重要信息。特别是，他们经常笼统地讨论"如何使用"某些东西，但掩盖了影响它们使用的安全属性。相反，手册页中有大量关于个别功能的详细信息，但手册页繁多的内容有时会掩盖重要的部分。本节试图弥合这一差距；它概述了 Linux 中可能被程序员使用的安全机制。本节比典型的编程指南更深入，特别关注与安全相关的问题，并指向可以获取更多详细信息的参考资料。Unix 程序员将处于熟悉的领域，但是有几个 Linux 扩展和细节可能会让他们感到惊讶。本节将尝试指出这些差异。

首先，基础知识。Linux 从根本上分为两部分：Linux 内核（及其内核模块）和"用户空间"，其中各种程序在内核之上执行。当用户登录时，他们的用户名被映射到整数，标记他们的"UID"（表示"user ID"）和他们所属的"GID"（表示"group ID"）.UID 0 是一个特殊的特权用户（角色），传统上称为"root"，可以否决大多数安全检查并用于管理系统。就安全性而言，进程是唯一的"主体"（即，只有进程是活动对象）。进程可以访问各种数据对象，特别是文件系统对象 (FSO)、System V 进程间通信 (IPC) 对象和网络端口。接下来的几节详细介绍了这一点。

## 3.1 进程(Processes)

在 Linux 中，用户级别的活动是通过运行进程来实现的。许多系统支持单独的"线程"；在 Linux 中，可以通过使用多个进程来实现不同的线程（Linux 内核然后执行优化以获得线程级速度）。

### 进程属性(Process Attributes)

每个进程都有一组与安全相关的属性，包括以下内容：

- RUID, RGID 
    
    代表进程运行的用户的真实 UID 和 GID
- EUID、EGID 
    
    用于权限检查的有效 UID 和 GID（文件系统除外）
- FSUID、FSGID 
    
    用于文件系统访问检查的 UID 和 GID；这通常分别等于 EUID 和 EGID。这是 Linux 独有的属性。
- SUID, SGID 

    保存的 UID 和 GID；用于支持切换权限"打开和关闭"，如下所述。
- groups 
    
    此用户具有成员资格的组 (GID) 列表。
- umask 

    创建新文件系统对象时确定默认访问控制设置的一组位；请参见 umask(2)。
- scheduling parameters 
    
    每个进程都有一个调度策略，默认策略 SCHED_OTHER 有额外的参数 nice、priority 和 counter。有关更多信息，请参阅 sched_setscheduler(2)。
- capabilities 
    
    POSIX capability信息；一个进程实际上有三组capability：
    - the effective-有效的
    - inheritable-可以继承的
    - permitted-允许的。有关 POSIX 功能的更多信息，请参见下文。
- limits 
    
    每个进程的资源限制（见下文）。
- filesystem root 
    
    进程关于根文件系统从哪里开始的判断；请参阅 chroot(2)。

如果您真的需要确切地知道与每个进程相关联的属性，请查看 Linux 源代码，特别是 include/linux/sched.h 对 task_struct 的定义。

### POSIX Capabilities

Linux 2.2 版增加了对"POSIX 功能"的内部支持。POSIX 功能支持将通常由 root 拥有的权限拆分为更大的一组更具体的权限。POSIX 功能由 IEEE 标准草案定义；它们不是 Linux 独有的，但它们也不是其他类 Unix 系统普遍支持的。当 Linux 文档（包括本文档）说`require root privilege`时，几乎在所有情况下，它的真正意思是`rquire a capability`，如功能文档中所述。如果您需要了解所需的特定功能，请在功能文档中查找。

最终目的是允许将功能附加到文件系统中的文件；但是，在撰写本文时，尚不支持此功能。支持传输功能，但默认情况下是禁用的。Linux 2.2.11 版添加了一个特性，使capability更直接有用，称为`capability bounding set`。能力边界集是系统上任何进程允许拥有的capability列表（否则，只有特殊的 init 进程可以拥有它）。如果一个capability没有出现在边界集中，它可能不会被任何进程行使，无论有多大的权限。例如，此功能可用于禁用内核模块加载。一个简单工具[LCAP](http://pweb.netcom.com/~spoon/lcap/)利用了这一点。

有关 POSIX 功能的更多信息，请访问 [ftp://linux.kernel.org/pub/linux/libs/security/linux-privs](ftp://linux.kernel.org/pub/linux/libs/security/linux-privs)。

### 进程创建和操作

进程可以使用 fork(2)、非推荐的 vfork(2) 或 Linux-unique clone(2) 创建；所有这些系统调用都复制了现有的进程，从中创建了两个进程。进程可以通过调用 execve(2) 或它的各种前端（例如，参见 exec(3)、system(3) 和 popen(3)）来执行不同的程序。

当一个程序被执行，并且它的文件设置了它的 setuid 或 setgid 位时，进程的 EUID 或 EGID（分别）被设置为文件。请注意，在 Linux 下，这不会发生在 shell 脚本等普通脚本中，因为在尝试使用脚本执行此操作时存在许多安全隐患（其他一些类 Unix 系统确实支持 setuid shell 脚本）。作为一种特殊情况，Perl 包括一个特殊的设置来支持 setuid Perl 脚本。

在某些情况下，进程会影响各种 UID 和 GID 值；请参阅 setuid(2)、seteuid(2)、setreuid(2)、setfsuid(2)。特别是 SUID 属性允许受信任的程序临时切换 UID。如果 RUID 更改，或者 EUID 设置为不等于 RUID 的值，则 SUID 将设置为新的 EUID。非特权用户可以将他们的 EUID 从他们的 SUID、RUID 设置为 EUID，将 EUID 设置为 RUID。

FSUID 进程属性旨在允许像 NFS 服务器这样的程序将自己限制为仅某些给定 UID 的文件系统权限，而不授予该 UID 向进程发送信号的权限。每当 EUID 更改时，FSUID 都会更改为新的 EUID 值；FSUID 值可以使用 setfsuid(2) 单独设置，这是 Linux 独有的调用。请注意，非 root 调用者只能将 FSUID 设置为当前的 RUID、EUID、SEUID 或当前的 FSUID 值。

## 3.2 文件系统

文件系统对象 (FSO) 可以是普通文件、目录、符号链接、命名管道 (FIFO)、套接字、字符特殊（设备）文件或块特殊（设备）文件（此列表显示在 find(1) 命令中） . 文件系统对象收集在文件系统上，可以在文件系统中的目录上挂载和卸载；文件系统的访问控制属性集可能略有不同，并且访问控制可能会受到挂载时选择的选项的影响。

### 文件系统对象属性

目前 ext2 是 Linux 系统上最流行的文件系统；它的每个文件系统对象支持以下属性：

- 拥有 UID 和 GID - 标识文件系统对象的"所有者"。除非另有说明，否则只有所有者或根用户才能更改访问控制属性。
- 每个用户（所有者）、组和其他人都有读取、写入、执行位。对于普通文件，read、write、execute都有其典型的含义。在目录中，"读取"权限是显示目录内容所必需的，而"执行"权限有时称为"搜索"权限，是实际进入目录以使用其内容所必需的。在目录中，对目录的"写"权限允许在该目录中添加、删除和重命名文件；如果您只想允许添加，请设置下面提到的`sticky`位。请注意，从未使用符号链接的权限值；重要的是它们包含的目录和链接到文件的值。
- `sticky` 位 
    
    在目录上设置时，取消链接（删除）仅限于 root、文件所有者或目录所有者。这是一个非常常见的 Unix 扩展，虽然不是很普遍。粘滞位对普通文件没有影响，普通用户可以开启该位。旧版本的 Unix 将此称为"保存程序文本"位，并用它来指示应该保留在内存中的可执行文件；Linux 的虚拟内存管理使这种使用变得无关紧要。
- setuid, setgid 
    
    当在可执行文件上设置时，执行该文件会将进程的effective UID 或有效 GID 分别设置为文件的owning UID 或 GID的值。所有类 Unix 系统都支持这一点。在目录上设置 setgid 时，在目录中创建的文件的 GID 将自动重置为目录的 GID。当在没有任何执行权限的文件上设置 setgid 时，这表示该文件在访问期间受到强制锁定（如果文件系统被挂载以支持强制锁定）；这种overload的意义让很多人感到惊讶，但在类 Unix 系统中并不普遍。
- 时间戳 
    
    为每个文件系统对象存储访问和修改时间。但是，所有者可以任意设置这些值（请参阅 touch(1)），因此在信任此信息时要小心。所有类 Unix 系统都支持这一点。
- immutable bit
    
    不允许更改文件系统对象；只有 root 可以设置或清除该位。这仅受 ext2 支持，并且不能跨所有 Unix 系统（甚至所有 Linux 文件系统）移植。
- append-only bit
    
    只允许附加到文件系统对象；只有 root 可以设置或清除该位。这仅受 ext2 支持，并且不能跨所有 Unix 系统（甚至所有 Linux 文件系统）移植。

许多这些值在安装时会受到影响，因此，例如，可以将某些位视为具有特定值（无论它们在介质上的值如何）。有关这方面的更多信息，请参阅 mount(1)。某些文件系统不支持其中一些访问控制值；同样，请参阅 mount(1) 以了解如何处理这些文件系统。

正在进行向文件系统添加访问控制列表 (ACL) 和 POSIX 功能值的工作，但这些在 Linux 2.2 中不存在。

### 创建时间初始值

在创建时，以下规则适用。当创建文件系统对象 (FSO) 时（例如通过 creat(2)），FSO 的 UID 被设置为进程的 FSUID。FSO GID 通常设置为进程的 FSGID，但如果设置了包含目录的 setgid 位或设置了文件系统的"GRPID"标志，则 FSO GID 设置为包含目录的 GID。这种特殊情况支持 ``project'' 目录：创建一个 ``project'' 目录，为该项目创建一个特殊的组，为该组拥有的项目创建一个目录，然后将目录设置为 setgid：放置在那里的文件项目自动拥有。类似地，如果在设置了 setgid 位的目录中创建了一个新的子目录（并且未设置文件系统 GRPID），新的子目录也将设置其 setgid 位（以便项目子目录"做正确的事"）；在所有其他情况下，新文件的 setgid 是明确的。FSO 基本访问控制值（读取、写入、执行）是根据（请求值和进程的 ~ umask）计算得出的。新文件总是以清除粘滞位和清除 setuid 位开头。

### 更改访问控制属性

您可以使用 chmod(2) 或 chmod(1) 设置大多数这些值，但另请参阅 chown(1)、chgrp(1) 和 chattr(1)。

请注意，在 Linux 中，只有 root 可以更改给定文件的所有者。一些类 Unix 系统允许普通用户更改所有权，但这会导致复杂化。

### 使用访问控制属性

在Linux和大多数类Unix系统下，读写属性值只在文件打开时检查；不会在每次读取或写入时重新检查它们。大量调用使用这些属性，因为文件系统对 Linux 来说非常重要。这包括 open(2)、creat(2)、link(2)、unlink(2)、rename(2)、mknod(2)、symlink(2) 和 socket(2)。

### 文件系统层次结构

多年来，"什么文件放在哪里"的规范已经建立好了；请遵循它们并在将信息放入层次结构时使用它们。此信息的摘要位于 hier(5) 中。有关文件系统层次结构标准 (FHS) 的更多信息，它是对先前 Linux 文件系统结构标准 (FSSTND) 的更新；见 http://www.pathname.com/fhs

## 3.3 系统 V IPC

Linux 支持 System V IPC 对象，即 System V 消息队列、信号量集和共享内存段。每个这样的对象都具有以下属性：

- 每个创建者、创建者组和others拥有读跟写权限。

- creator UID 和 GID 
    
    对象创建者的 UID 和 GID。
- owning UID 和 GID 
    
    对象所有者的 UID 和 GID（最初等于创建者 UID）。

访问此类对象时，规则如下：

- 如果该进程具有 root 权限，则授予访问权限。
- 如果进程的 EUID 是对象的所有者或创建者 UID，则检查相应的创建者权限位以查看是否授予访问权限。
- 如果进程的 EGID 是对象的所有者或创建者 GID，或者进程的组里有一个是对象的拥有者或创建者 GID，则检查适当的创建者组权限位以进行访问。
- 否则，检查适当的"其他"权限位以进行访问。

请注意，root 或具有所有者或创建者的 EUID 的进程可以设置拥有 UID 和拥有 GID 和/或删除对象。更多信息可在 ipc(5) 中获得。

## 3.4 套接字和网络连接

套接字用于通信，尤其是通过**网络**进行通信。Socket(2) 创建通信端点并返回描述符(descriptor)；有关更多信息和对其他相关信息的交叉引用，请参阅 socket(2)。请注意，绑定到小于 1024 的 TCP 和 UDP 本地端口号在 Linux 中需要 root 权限（绑定到小于 1024 的远程端口号不需要特殊权限）。

## 3.5 配额和限制

Linux 具有支持文件系统配额和进程资源限制的机制。请注意这里的术语，因为它们都有"硬"和"软"限制，但术语的含义略有不同。

您可以为每个挂载点定义存储（文件系统）配额限制，指定用户或组可以使用的存储块数量和/或唯一文件（inodes）数量。"硬"配额限制是永不超过的限制，而"软"配额可以暂时超过。请参阅 quota(1)、quotactl(2) 和 quotaon(8)。

rlimit 机制支持大量的进程配额，例如文件大小、子进程数、打开文件数等。有"软"限制（也称为当前限制）和"硬限制"（也称为上限）。任何时候都不能超过软限制，但可
以通过调用将其提高到硬限制的值。请参阅 getrlimit()、setrlimit() 和 getrusage()。

## 3.6 审计

目前最常见的"审计"机制是 syslogd(8)。您可能还想查看 wtmp(5)、utmp(5)、lastlog(8) 和 acct(2)。一些服务器程序（例如 Apache Web 服务器）也有自己的审计跟踪机制。

## 3.7 PAM

进行身份验证时，大多数 Linux 系统使用可插拔身份验证模块 (PAM)。这允许配置身份验证（例如，使用密码、智能卡等）。本文档稍后将更全面地讨论 PAM。